# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T04:22:28+00:00



import argparse
import json
import os
from ipaddress import IPv6Address
from typing import *
from typing import Optional, Union
from uuid import UUID

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import (
    BaseSecurity,
    HTTPBearer,
    UnsuportedSecurityStub,
)
from fastapi import Path, UploadFile
from pydantic import conint

from models import (
    Account,
    AccountCancelPostRequest,
    AccountCancelPostResponse,
    AccountCancelPostResponse1,
    AccountCancelPostResponse2,
    AccountCreditCardPostResponse,
    AccountCreditCardPostResponse1,
    AccountEntityTransfersGetResponse,
    AccountEntityTransfersGetResponse1,
    AccountEntityTransfersPostRequest,
    AccountEntityTransfersPostResponse,
    AccountEntityTransfersTokenAcceptPostResponse,
    AccountEntityTransfersTokenAcceptPostResponse1,
    AccountEntityTransfersTokenDeleteResponse,
    AccountEntityTransfersTokenDeleteResponse1,
    AccountEntityTransfersTokenGetResponse,
    AccountEventsEventIdGetResponse,
    AccountEventsEventIdReadPostResponse,
    AccountEventsEventIdReadPostResponse1,
    AccountEventsEventIdSeenPostResponse,
    AccountEventsEventIdSeenPostResponse1,
    AccountEventsGetResponse,
    AccountEventsGetResponse1,
    AccountGetResponse,
    AccountInvoicesGetResponse,
    AccountInvoicesGetResponse1,
    AccountInvoicesInvoiceIdGetResponse,
    AccountInvoicesInvoiceIdItemsGetResponse,
    AccountInvoicesInvoiceIdItemsGetResponse1,
    AccountLoginsGetResponse,
    AccountLoginsGetResponse1,
    AccountLoginsLoginIdGetResponse,
    AccountMaintenanceGetResponse,
    AccountMaintenanceGetResponse1,
    AccountNotificationsGetResponse,
    AccountNotificationsGetResponse1,
    AccountOauthClientsClientIdDeleteResponse,
    AccountOauthClientsClientIdDeleteResponse1,
    AccountOauthClientsClientIdGetResponse,
    AccountOauthClientsClientIdPutResponse,
    AccountOauthClientsClientIdResetSecretPostResponse,
    AccountOauthClientsClientIdThumbnailGetResponse,
    AccountOauthClientsClientIdThumbnailPutResponse,
    AccountOauthClientsClientIdThumbnailPutResponse1,
    AccountOauthClientsGetResponse,
    AccountOauthClientsGetResponse1,
    AccountOauthClientsPostRequest,
    AccountOauthClientsPostResponse,
    AccountPaymentMethodsGetResponse,
    AccountPaymentMethodsGetResponse1,
    AccountPaymentMethodsPaymentMethodIdDeleteResponse,
    AccountPaymentMethodsPaymentMethodIdDeleteResponse1,
    AccountPaymentMethodsPaymentMethodIdGetResponse,
    AccountPaymentMethodsPaymentMethodIdMakeDefaultPostResponse,
    AccountPaymentMethodsPaymentMethodIdMakeDefaultPostResponse1,
    AccountPaymentMethodsPostRequest,
    AccountPaymentMethodsPostResponse,
    AccountPaymentMethodsPostResponse1,
    AccountPaymentsGetResponse,
    AccountPaymentsGetResponse1,
    AccountPaymentsPaymentIdGetResponse,
    AccountPaymentsPaypalExecutePostResponse,
    AccountPaymentsPaypalExecutePostResponse1,
    AccountPaymentsPaypalExecutePostResponse3,
    AccountPaymentsPaypalPostResponse,
    AccountPaymentsPaypalPostResponse1,
    AccountPaymentsPaypalPostResponse2,
    AccountPaymentsPostResponse,
    AccountPaymentsPostResponse1,
    AccountPromoCodesPostRequest,
    AccountPromoCodesPostResponse,
    AccountPutResponse,
    AccountServiceTransfersGetResponse,
    AccountServiceTransfersGetResponse1,
    AccountServiceTransfersPostRequest,
    AccountServiceTransfersPostResponse,
    AccountServiceTransfersTokenAcceptPostResponse,
    AccountServiceTransfersTokenAcceptPostResponse1,
    AccountServiceTransfersTokenDeleteResponse,
    AccountServiceTransfersTokenDeleteResponse1,
    AccountServiceTransfersTokenGetResponse,
    AccountSettings,
    AccountSettingsGetResponse,
    AccountSettingsManagedEnablePostResponse,
    AccountSettingsManagedEnablePostResponse1,
    AccountSettingsPutResponse,
    AccountTransferGetResponse,
    AccountUsersGetResponse,
    AccountUsersGetResponse1,
    AccountUsersPostRequest,
    AccountUsersPostResponse,
    AccountUsersUsernameDeleteResponse,
    AccountUsersUsernameDeleteResponse1,
    AccountUsersUsernameGetResponse,
    AccountUsersUsernameGrantsGetResponse,
    AccountUsersUsernameGrantsPutResponse,
    AccountUsersUsernamePutResponse,
    AuthorizedApp,
    Backup,
    CreditCard1,
    DatabaseBackup,
    DatabaseBackupSnapshot,
    DatabaseCredentials,
    DatabaseEngine,
    DatabaseMongoDB,
    DatabaseMySQL,
    DatabaseMySQLRequest,
    DatabasePostgreSQL,
    DatabasePostgreSQLRequest,
    DatabasesEnginesEngineIdGetResponse,
    DatabasesEnginesGetResponse,
    DatabasesEnginesGetResponse1,
    DatabasesInstancesGetResponse,
    DatabasesInstancesGetResponse1,
    DatabasesMongodbInstancesGetResponse,
    DatabasesMongodbInstancesGetResponse1,
    DatabasesMongodbInstancesInstanceIdBackupsBackupIdDeleteResponse,
    DatabasesMongodbInstancesInstanceIdBackupsBackupIdDeleteResponse1,
    DatabasesMongodbInstancesInstanceIdBackupsBackupIdGetResponse,
    DatabasesMongodbInstancesInstanceIdBackupsBackupIdRestorePostResponse,
    DatabasesMongodbInstancesInstanceIdBackupsBackupIdRestorePostResponse1,
    DatabasesMongodbInstancesInstanceIdBackupsGetResponse,
    DatabasesMongodbInstancesInstanceIdBackupsGetResponse1,
    DatabasesMongodbInstancesInstanceIdBackupsPostResponse,
    DatabasesMongodbInstancesInstanceIdBackupsPostResponse1,
    DatabasesMongodbInstancesInstanceIdCredentialsGetResponse,
    DatabasesMongodbInstancesInstanceIdCredentialsResetPostResponse,
    DatabasesMongodbInstancesInstanceIdCredentialsResetPostResponse1,
    DatabasesMongodbInstancesInstanceIdDeleteResponse,
    DatabasesMongodbInstancesInstanceIdDeleteResponse1,
    DatabasesMongodbInstancesInstanceIdGetResponse,
    DatabasesMongodbInstancesInstanceIdPatchPostResponse,
    DatabasesMongodbInstancesInstanceIdPatchPostResponse1,
    DatabasesMongodbInstancesInstanceIdPutRequest,
    DatabasesMongodbInstancesInstanceIdPutResponse,
    DatabasesMongodbInstancesInstanceIdSslGetResponse,
    DatabasesMysqlInstancesGetResponse,
    DatabasesMysqlInstancesGetResponse1,
    DatabasesMysqlInstancesInstanceIdBackupsBackupIdDeleteResponse,
    DatabasesMysqlInstancesInstanceIdBackupsBackupIdDeleteResponse1,
    DatabasesMysqlInstancesInstanceIdBackupsBackupIdGetResponse,
    DatabasesMysqlInstancesInstanceIdBackupsBackupIdRestorePostResponse,
    DatabasesMysqlInstancesInstanceIdBackupsBackupIdRestorePostResponse1,
    DatabasesMysqlInstancesInstanceIdBackupsGetResponse,
    DatabasesMysqlInstancesInstanceIdBackupsGetResponse1,
    DatabasesMysqlInstancesInstanceIdBackupsPostResponse,
    DatabasesMysqlInstancesInstanceIdBackupsPostResponse1,
    DatabasesMysqlInstancesInstanceIdCredentialsGetResponse,
    DatabasesMysqlInstancesInstanceIdCredentialsResetPostResponse,
    DatabasesMysqlInstancesInstanceIdCredentialsResetPostResponse1,
    DatabasesMysqlInstancesInstanceIdDeleteResponse,
    DatabasesMysqlInstancesInstanceIdDeleteResponse1,
    DatabasesMysqlInstancesInstanceIdGetResponse,
    DatabasesMysqlInstancesInstanceIdPatchPostResponse,
    DatabasesMysqlInstancesInstanceIdPatchPostResponse1,
    DatabasesMysqlInstancesInstanceIdPutRequest,
    DatabasesMysqlInstancesInstanceIdPutResponse,
    DatabasesMysqlInstancesInstanceIdSslGetResponse,
    DatabasesMysqlInstancesPostResponse,
    DatabasesPostgresqlInstancesGetResponse,
    DatabasesPostgresqlInstancesGetResponse1,
    DatabasesPostgresqlInstancesInstanceIdBackupsBackupIdDeleteResponse,
    DatabasesPostgresqlInstancesInstanceIdBackupsBackupIdDeleteResponse1,
    DatabasesPostgresqlInstancesInstanceIdBackupsBackupIdGetResponse,
    DatabasesPostgresqlInstancesInstanceIdBackupsBackupIdRestorePostResponse,
    DatabasesPostgresqlInstancesInstanceIdBackupsBackupIdRestorePostResponse1,
    DatabasesPostgresqlInstancesInstanceIdBackupsGetResponse,
    DatabasesPostgresqlInstancesInstanceIdBackupsGetResponse1,
    DatabasesPostgresqlInstancesInstanceIdBackupsPostResponse,
    DatabasesPostgresqlInstancesInstanceIdBackupsPostResponse1,
    DatabasesPostgresqlInstancesInstanceIdCredentialsGetResponse,
    DatabasesPostgresqlInstancesInstanceIdCredentialsResetPostResponse,
    DatabasesPostgresqlInstancesInstanceIdCredentialsResetPostResponse1,
    DatabasesPostgresqlInstancesInstanceIdDeleteResponse,
    DatabasesPostgresqlInstancesInstanceIdDeleteResponse1,
    DatabasesPostgresqlInstancesInstanceIdGetResponse,
    DatabasesPostgresqlInstancesInstanceIdPatchPostResponse,
    DatabasesPostgresqlInstancesInstanceIdPatchPostResponse1,
    DatabasesPostgresqlInstancesInstanceIdPutRequest,
    DatabasesPostgresqlInstancesInstanceIdPutResponse,
    DatabasesPostgresqlInstancesInstanceIdSslGetResponse,
    DatabasesPostgresqlInstancesPostResponse,
    DatabaseSSL,
    DatabasesTypesGetResponse,
    DatabasesTypesGetResponse1,
    DatabasesTypesTypeIdGetResponse,
    DatabaseType,
    Disk1,
    Domain,
    DomainRecord,
    DomainsDomainIdClonePostRequest,
    DomainsDomainIdClonePostResponse,
    DomainsDomainIdDeleteResponse,
    DomainsDomainIdDeleteResponse1,
    DomainsDomainIdGetResponse,
    DomainsDomainIdPutResponse,
    DomainsDomainIdRecordsGetResponse,
    DomainsDomainIdRecordsPostRequest,
    DomainsDomainIdRecordsPostResponse,
    DomainsDomainIdRecordsRecordIdDeleteResponse,
    DomainsDomainIdRecordsRecordIdDeleteResponse1,
    DomainsDomainIdRecordsRecordIdGetResponse,
    DomainsDomainIdRecordsRecordIdPutRequest,
    DomainsDomainIdRecordsRecordIdPutResponse,
    DomainsDomainIdZoneFileGetResponse,
    DomainsDomainIdZoneFileGetResponse1,
    DomainsGetResponse,
    DomainsGetResponse1,
    DomainsImportPostRequest,
    DomainsImportPostResponse,
    DomainsPostRequest,
    DomainsPostResponse,
    EntityTransfer,
    Event,
    Firewall,
    FirewallDevices,
    GrantsResponse,
    Image,
    ImagesGetResponse,
    ImagesGetResponse1,
    ImagesImageIdDeleteResponse,
    ImagesImageIdDeleteResponse1,
    ImagesImageIdGetResponse,
    ImagesImageIdPutResponse,
    ImagesPostRequest,
    ImagesPostResponse,
    ImagesUploadPostRequest,
    ImagesUploadPostResponse,
    ImagesUploadPostResponse1,
    Invoice,
    IPAddress,
    IPAddressesAssignRequest,
    IPAddressesShareRequest,
    IPv6RangeBGP,
    Kernel,
    Linode,
    LinodeConfig,
    LinodeInstancesGetResponse,
    LinodeInstancesGetResponse1,
    LinodeInstancesLinodeIdBackupsBackupIdGetResponse,
    LinodeInstancesLinodeIdBackupsBackupIdRestorePostRequest,
    LinodeInstancesLinodeIdBackupsBackupIdRestorePostResponse,
    LinodeInstancesLinodeIdBackupsBackupIdRestorePostResponse1,
    LinodeInstancesLinodeIdBackupsCancelPostResponse,
    LinodeInstancesLinodeIdBackupsCancelPostResponse1,
    LinodeInstancesLinodeIdBackupsEnablePostResponse,
    LinodeInstancesLinodeIdBackupsEnablePostResponse1,
    LinodeInstancesLinodeIdBackupsGetResponse,
    LinodeInstancesLinodeIdBackupsGetResponse1,
    LinodeInstancesLinodeIdBackupsPostRequest,
    LinodeInstancesLinodeIdBackupsPostResponse,
    LinodeInstancesLinodeIdBootPostRequest,
    LinodeInstancesLinodeIdBootPostResponse,
    LinodeInstancesLinodeIdBootPostResponse1,
    LinodeInstancesLinodeIdClonePostRequest,
    LinodeInstancesLinodeIdClonePostResponse,
    LinodeInstancesLinodeIdConfigsConfigIdDeleteResponse,
    LinodeInstancesLinodeIdConfigsConfigIdDeleteResponse1,
    LinodeInstancesLinodeIdConfigsConfigIdGetResponse,
    LinodeInstancesLinodeIdConfigsConfigIdPutResponse,
    LinodeInstancesLinodeIdConfigsGetResponse,
    LinodeInstancesLinodeIdConfigsPostRequest,
    LinodeInstancesLinodeIdConfigsPostResponse,
    LinodeInstancesLinodeIdDeleteResponse,
    LinodeInstancesLinodeIdDeleteResponse1,
    LinodeInstancesLinodeIdDisksDiskIdClonePostResponse,
    LinodeInstancesLinodeIdDisksDiskIdDeleteResponse,
    LinodeInstancesLinodeIdDisksDiskIdDeleteResponse1,
    LinodeInstancesLinodeIdDisksDiskIdGetResponse,
    LinodeInstancesLinodeIdDisksDiskIdPasswordPostRequest,
    LinodeInstancesLinodeIdDisksDiskIdPasswordPostResponse,
    LinodeInstancesLinodeIdDisksDiskIdPasswordPostResponse1,
    LinodeInstancesLinodeIdDisksDiskIdPutResponse,
    LinodeInstancesLinodeIdDisksDiskIdResizePostRequest,
    LinodeInstancesLinodeIdDisksDiskIdResizePostResponse,
    LinodeInstancesLinodeIdDisksDiskIdResizePostResponse1,
    LinodeInstancesLinodeIdDisksGetResponse,
    LinodeInstancesLinodeIdDisksGetResponse1,
    LinodeInstancesLinodeIdDisksPostRequest,
    LinodeInstancesLinodeIdDisksPostResponse,
    LinodeInstancesLinodeIdFirewallsGetResponse,
    LinodeInstancesLinodeIdFirewallsGetResponse1,
    LinodeInstancesLinodeIdGetResponse,
    LinodeInstancesLinodeIdIpsAddressDeleteResponse,
    LinodeInstancesLinodeIdIpsAddressDeleteResponse1,
    LinodeInstancesLinodeIdIpsAddressGetResponse,
    LinodeInstancesLinodeIdIpsAddressPutRequest,
    LinodeInstancesLinodeIdIpsAddressPutResponse,
    LinodeInstancesLinodeIdIpsGetResponse,
    LinodeInstancesLinodeIdIpsGetResponse1,
    LinodeInstancesLinodeIdIpsPostRequest,
    LinodeInstancesLinodeIdIpsPostResponse,
    LinodeInstancesLinodeIdMigratePostRequest,
    LinodeInstancesLinodeIdMigratePostResponse,
    LinodeInstancesLinodeIdMigratePostResponse1,
    LinodeInstancesLinodeIdMutatePostRequest,
    LinodeInstancesLinodeIdMutatePostResponse,
    LinodeInstancesLinodeIdMutatePostResponse1,
    LinodeInstancesLinodeIdNodebalancersGetResponse,
    LinodeInstancesLinodeIdPasswordPostRequest,
    LinodeInstancesLinodeIdPasswordPostResponse,
    LinodeInstancesLinodeIdPasswordPostResponse1,
    LinodeInstancesLinodeIdPutResponse,
    LinodeInstancesLinodeIdRebootPostRequest,
    LinodeInstancesLinodeIdRebootPostResponse,
    LinodeInstancesLinodeIdRebootPostResponse1,
    LinodeInstancesLinodeIdRebuildPostRequest,
    LinodeInstancesLinodeIdRebuildPostResponse,
    LinodeInstancesLinodeIdRescuePostRequest,
    LinodeInstancesLinodeIdRescuePostResponse,
    LinodeInstancesLinodeIdRescuePostResponse1,
    LinodeInstancesLinodeIdResizePostRequest,
    LinodeInstancesLinodeIdResizePostResponse,
    LinodeInstancesLinodeIdResizePostResponse1,
    LinodeInstancesLinodeIdShutdownPostResponse,
    LinodeInstancesLinodeIdShutdownPostResponse1,
    LinodeInstancesLinodeIdStatsGetResponse,
    LinodeInstancesLinodeIdStatsYearMonthGetResponse,
    LinodeInstancesLinodeIdTransferGetResponse,
    LinodeInstancesLinodeIdTransferGetResponse1,
    LinodeInstancesLinodeIdTransferYearMonthGetResponse,
    LinodeInstancesLinodeIdTransferYearMonthGetResponse1,
    LinodeInstancesLinodeIdVolumesGetResponse,
    LinodeInstancesLinodeIdVolumesGetResponse1,
    LinodeInstancesPostRequest,
    LinodeInstancesPostResponse,
    LinodeKernelsGetResponse,
    LinodeKernelsGetResponse1,
    LinodeKernelsKernelIdGetResponse,
    LinodeStackscriptsGetResponse,
    LinodeStackscriptsGetResponse1,
    LinodeStackscriptsPostRequest,
    LinodeStackscriptsPostResponse,
    LinodeStackscriptsStackscriptIdDeleteResponse,
    LinodeStackscriptsStackscriptIdDeleteResponse1,
    LinodeStackscriptsStackscriptIdGetResponse,
    LinodeStackscriptsStackscriptIdPutResponse,
    LinodeStats,
    LinodeType,
    LinodeTypesGetResponse,
    LinodeTypesGetResponse1,
    LinodeTypesTypeIdGetResponse,
    LKECluster,
    LkeClustersClusterIdApiEndpointsGetResponse,
    LkeClustersClusterIdApiEndpointsGetResponse1,
    LkeClustersClusterIdDashboardGetResponse,
    LkeClustersClusterIdDashboardGetResponse1,
    LkeClustersClusterIdDeleteResponse,
    LkeClustersClusterIdDeleteResponse1,
    LkeClustersClusterIdGetResponse,
    LkeClustersClusterIdKubeconfigDeleteResponse,
    LkeClustersClusterIdKubeconfigDeleteResponse1,
    LkeClustersClusterIdKubeconfigGetResponse,
    LkeClustersClusterIdKubeconfigGetResponse1,
    LkeClustersClusterIdNodesNodeIdDeleteResponse,
    LkeClustersClusterIdNodesNodeIdDeleteResponse1,
    LkeClustersClusterIdNodesNodeIdGetResponse,
    LkeClustersClusterIdNodesNodeIdGetResponse1,
    LkeClustersClusterIdNodesNodeIdRecyclePostResponse,
    LkeClustersClusterIdNodesNodeIdRecyclePostResponse1,
    LkeClustersClusterIdPoolsGetResponse,
    LkeClustersClusterIdPoolsGetResponse1,
    LkeClustersClusterIdPoolsPoolIdDeleteResponse,
    LkeClustersClusterIdPoolsPoolIdDeleteResponse1,
    LkeClustersClusterIdPoolsPoolIdPutRequest,
    LkeClustersClusterIdPoolsPoolIdRecyclePostResponse,
    LkeClustersClusterIdPoolsPoolIdRecyclePostResponse1,
    LkeClustersClusterIdPoolsPostRequest,
    LkeClustersClusterIdPoolsPostResponse,
    LkeClustersClusterIdPutRequest,
    LkeClustersClusterIdPutResponse,
    LkeClustersClusterIdRecyclePostResponse,
    LkeClustersClusterIdRecyclePostResponse1,
    LkeClustersClusterIdRegeneratePostRequest,
    LkeClustersClusterIdRegeneratePostResponse,
    LkeClustersClusterIdRegeneratePostResponse1,
    LkeClustersClusterIdServicetokenDeleteResponse,
    LkeClustersClusterIdServicetokenDeleteResponse1,
    LkeClustersGetResponse,
    LkeClustersGetResponse1,
    LkeClustersPostRequest,
    LkeClustersPostResponse,
    LKENodePool,
    LKEVersion,
    LkeVersionsGetResponse,
    LkeVersionsGetResponse1,
    LkeVersionsVersionGetResponse,
    Login,
    LongviewClient,
    LongviewClientsClientIdDeleteResponse,
    LongviewClientsClientIdDeleteResponse1,
    LongviewClientsClientIdGetResponse,
    LongviewClientsClientIdPutResponse,
    LongviewClientsGetResponse,
    LongviewClientsGetResponse1,
    LongviewClientsPostResponse,
    LongviewPlan,
    LongviewPlanGetResponse,
    LongviewPlanPutResponse,
    LongviewSubscription1,
    LongviewSubscriptionsGetResponse,
    LongviewSubscriptionsGetResponse1,
    LongviewSubscriptionsSubscriptionIdGetResponse,
    ManagedContact,
    ManagedContactsContactIdDeleteResponse,
    ManagedContactsContactIdDeleteResponse1,
    ManagedContactsContactIdGetResponse,
    ManagedContactsContactIdPutResponse,
    ManagedContactsGetResponse,
    ManagedContactsGetResponse1,
    ManagedContactsPostResponse,
    ManagedCredential,
    ManagedCredentialsCredentialIdGetResponse,
    ManagedCredentialsCredentialIdPutResponse,
    ManagedCredentialsCredentialIdRevokePostResponse,
    ManagedCredentialsCredentialIdRevokePostResponse1,
    ManagedCredentialsCredentialIdUpdatePostRequest,
    ManagedCredentialsCredentialIdUpdatePostResponse,
    ManagedCredentialsCredentialIdUpdatePostResponse1,
    ManagedCredentialsGetResponse,
    ManagedCredentialsGetResponse1,
    ManagedCredentialsPostRequest,
    ManagedCredentialsPostResponse,
    ManagedCredentialsSshkeyGetResponse,
    ManagedCredentialsSshkeyGetResponse1,
    ManagedIssue,
    ManagedIssuesGetResponse,
    ManagedIssuesGetResponse1,
    ManagedIssuesIssueIdGetResponse,
    ManagedLinodeSettings,
    ManagedLinodeSettingsGetResponse,
    ManagedLinodeSettingsGetResponse1,
    ManagedLinodeSettingsLinodeIdGetResponse,
    ManagedLinodeSettingsLinodeIdPutResponse,
    ManagedService,
    ManagedServicesGetResponse,
    ManagedServicesGetResponse1,
    ManagedServicesPostRequest,
    ManagedServicesPostResponse,
    ManagedServicesServiceIdDeleteResponse,
    ManagedServicesServiceIdDeleteResponse1,
    ManagedServicesServiceIdDisablePostResponse,
    ManagedServicesServiceIdEnablePostResponse,
    ManagedServicesServiceIdGetResponse,
    ManagedServicesServiceIdPutResponse,
    ManagedStatsGetResponse,
    ManagedStatsGetResponse1,
    NetworkingFirewallsFirewallIdDeleteResponse,
    NetworkingFirewallsFirewallIdDeleteResponse1,
    NetworkingFirewallsFirewallIdDevicesDeviceIdDeleteResponse,
    NetworkingFirewallsFirewallIdDevicesDeviceIdDeleteResponse1,
    NetworkingFirewallsFirewallIdDevicesDeviceIdGetResponse,
    NetworkingFirewallsFirewallIdDevicesGetResponse,
    NetworkingFirewallsFirewallIdDevicesGetResponse1,
    NetworkingFirewallsFirewallIdDevicesPostRequest,
    NetworkingFirewallsFirewallIdDevicesPostResponse,
    NetworkingFirewallsFirewallIdGetResponse,
    NetworkingFirewallsFirewallIdPutRequest,
    NetworkingFirewallsFirewallIdPutResponse,
    NetworkingFirewallsFirewallIdRulesGetResponse,
    NetworkingFirewallsFirewallIdRulesPutRequest,
    NetworkingFirewallsFirewallIdRulesPutResponse,
    NetworkingFirewallsGetResponse,
    NetworkingFirewallsGetResponse1,
    NetworkingFirewallsPostRequest,
    NetworkingFirewallsPostResponse,
    NetworkingIpsAddressGetResponse,
    NetworkingIpsAddressPutRequest,
    NetworkingIpsAddressPutResponse,
    NetworkingIpsAssignPostResponse,
    NetworkingIpsAssignPostResponse1,
    NetworkingIpsGetResponse,
    NetworkingIpsGetResponse1,
    NetworkingIpsPostRequest,
    NetworkingIpsPostResponse,
    NetworkingIpsSharePostResponse,
    NetworkingIpsSharePostResponse1,
    NetworkingIpv4AssignPostResponse,
    NetworkingIpv4AssignPostResponse1,
    NetworkingIpv4SharePostResponse,
    NetworkingIpv4SharePostResponse1,
    NetworkingIpv6PoolsGetResponse,
    NetworkingIpv6PoolsGetResponse1,
    NetworkingIpv6RangesGetResponse,
    NetworkingIpv6RangesGetResponse1,
    NetworkingIpv6RangesPostRequest,
    NetworkingIpv6RangesPostResponse,
    NetworkingIpv6RangesPostResponse1,
    NetworkingIpv6RangesRangeDeleteResponse,
    NetworkingIpv6RangesRangeDeleteResponse1,
    NetworkingIpv6RangesRangeGetResponse,
    NetworkingVlansGetResponse,
    NetworkingVlansGetResponse1,
    NodeBalancer,
    NodeBalancerConfig,
    NodeBalancerNode,
    NodebalancersGetResponse,
    NodebalancersGetResponse1,
    NodebalancersNodeBalancerIdConfigsConfigIdDeleteResponse,
    NodebalancersNodeBalancerIdConfigsConfigIdDeleteResponse1,
    NodebalancersNodeBalancerIdConfigsConfigIdGetResponse,
    NodebalancersNodeBalancerIdConfigsConfigIdNodesGetResponse,
    NodebalancersNodeBalancerIdConfigsConfigIdNodesGetResponse1,
    NodebalancersNodeBalancerIdConfigsConfigIdNodesNodeIdDeleteResponse,
    NodebalancersNodeBalancerIdConfigsConfigIdNodesNodeIdDeleteResponse1,
    NodebalancersNodeBalancerIdConfigsConfigIdNodesNodeIdGetResponse,
    NodebalancersNodeBalancerIdConfigsConfigIdNodesNodeIdPutResponse,
    NodebalancersNodeBalancerIdConfigsConfigIdNodesPostRequest,
    NodebalancersNodeBalancerIdConfigsConfigIdNodesPostResponse,
    NodebalancersNodeBalancerIdConfigsConfigIdPutResponse,
    NodebalancersNodeBalancerIdConfigsConfigIdRebuildPostRequest,
    NodebalancersNodeBalancerIdConfigsConfigIdRebuildPostResponse,
    NodebalancersNodeBalancerIdConfigsGetResponse,
    NodebalancersNodeBalancerIdConfigsGetResponse1,
    NodebalancersNodeBalancerIdConfigsPostResponse,
    NodebalancersNodeBalancerIdDeleteResponse,
    NodebalancersNodeBalancerIdDeleteResponse1,
    NodebalancersNodeBalancerIdGetResponse,
    NodebalancersNodeBalancerIdPutResponse,
    NodebalancersNodeBalancerIdStatsGetResponse,
    NodebalancersPostRequest,
    NodebalancersPostResponse,
    NodeBalancerStats,
    OAuthClient,
    ObjectStorageBucket,
    ObjectStorageBucketsClusterIdBucketAccessPostRequest,
    ObjectStorageBucketsClusterIdBucketAccessPostResponse,
    ObjectStorageBucketsClusterIdBucketAccessPostResponse1,
    ObjectStorageBucketsClusterIdBucketAccessPutRequest,
    ObjectStorageBucketsClusterIdBucketAccessPutResponse,
    ObjectStorageBucketsClusterIdBucketAccessPutResponse1,
    ObjectStorageBucketsClusterIdBucketDeleteResponse,
    ObjectStorageBucketsClusterIdBucketDeleteResponse1,
    ObjectStorageBucketsClusterIdBucketGetResponse,
    ObjectStorageBucketsClusterIdBucketObjectAclGetResponse,
    ObjectStorageBucketsClusterIdBucketObjectAclGetResponse1,
    ObjectStorageBucketsClusterIdBucketObjectAclPutRequest,
    ObjectStorageBucketsClusterIdBucketObjectAclPutResponse,
    ObjectStorageBucketsClusterIdBucketObjectAclPutResponse1,
    ObjectStorageBucketsClusterIdBucketObjectListGetResponse,
    ObjectStorageBucketsClusterIdBucketObjectListGetResponse1,
    ObjectStorageBucketsClusterIdBucketObjectUrlPostRequest,
    ObjectStorageBucketsClusterIdBucketObjectUrlPostResponse,
    ObjectStorageBucketsClusterIdBucketObjectUrlPostResponse1,
    ObjectStorageBucketsClusterIdBucketSslDeleteResponse,
    ObjectStorageBucketsClusterIdBucketSslDeleteResponse1,
    ObjectStorageBucketsClusterIdBucketSslGetResponse,
    ObjectStorageBucketsClusterIdBucketSslPostResponse,
    ObjectStorageBucketsClusterIdGetResponse,
    ObjectStorageBucketsClusterIdGetResponse1,
    ObjectStorageBucketsGetResponse,
    ObjectStorageBucketsGetResponse1,
    ObjectStorageBucketsPostRequest,
    ObjectStorageBucketsPostResponse,
    ObjectStorageCancelPostResponse,
    ObjectStorageCancelPostResponse1,
    ObjectStorageCluster,
    ObjectStorageClustersClusterIdGetResponse,
    ObjectStorageClustersGetResponse,
    ObjectStorageClustersGetResponse1,
    ObjectStorageKey,
    ObjectStorageKeysGetResponse,
    ObjectStorageKeysGetResponse1,
    ObjectStorageKeysKeyIdDeleteResponse,
    ObjectStorageKeysKeyIdDeleteResponse1,
    ObjectStorageKeysKeyIdGetResponse,
    ObjectStorageKeysKeyIdPutRequest,
    ObjectStorageKeysKeyIdPutResponse,
    ObjectStorageKeysPostResponse,
    ObjectStorageSSL,
    ObjectStorageSSLResponse,
    ObjectStorageTransferGetResponse,
    ObjectStorageTransferGetResponse1,
    Payment,
    PaymentMethod,
    PaymentRequest,
    PayPal,
    PayPalExecute,
    PersonalAccessToken,
    Profile,
    ProfileAppsAppIdDeleteResponse,
    ProfileAppsAppIdDeleteResponse1,
    ProfileAppsAppIdGetResponse,
    ProfileAppsGetResponse,
    ProfileAppsGetResponse1,
    ProfileDevicesDeviceIdDeleteResponse,
    ProfileDevicesDeviceIdDeleteResponse1,
    ProfileDevicesDeviceIdGetResponse,
    ProfileDevicesGetResponse,
    ProfileDevicesGetResponse1,
    ProfileGetResponse,
    ProfileGrantsGetResponse,
    ProfileLoginsGetResponse,
    ProfileLoginsGetResponse1,
    ProfileLoginsLoginIdGetResponse,
    ProfilePhoneNumberDeleteResponse,
    ProfilePhoneNumberDeleteResponse1,
    ProfilePhoneNumberPostRequest,
    ProfilePhoneNumberPostResponse,
    ProfilePhoneNumberPostResponse1,
    ProfilePhoneNumberVerifyPostRequest,
    ProfilePhoneNumberVerifyPostResponse,
    ProfilePhoneNumberVerifyPostResponse1,
    ProfilePreferencesGetResponse,
    ProfilePreferencesGetResponse1,
    ProfilePreferencesPutRequest,
    ProfilePreferencesPutResponse,
    ProfilePreferencesPutResponse1,
    ProfilePutResponse,
    ProfileSecurityQuestionsGetResponse,
    ProfileSecurityQuestionsPostResponse,
    ProfileSshkeysGetResponse,
    ProfileSshkeysGetResponse1,
    ProfileSshkeysPostResponse,
    ProfileSshkeysSshKeyIdDeleteResponse,
    ProfileSshkeysSshKeyIdDeleteResponse1,
    ProfileSshkeysSshKeyIdGetResponse,
    ProfileSshkeysSshKeyIdPutRequest,
    ProfileSshkeysSshKeyIdPutResponse,
    ProfileTfaDisablePostResponse,
    ProfileTfaDisablePostResponse1,
    ProfileTfaEnableConfirmPostRequest,
    ProfileTfaEnableConfirmPostResponse,
    ProfileTfaEnableConfirmPostResponse1,
    ProfileTfaEnablePostResponse,
    ProfileTfaEnablePostResponse1,
    ProfileTokensGetResponse,
    ProfileTokensGetResponse1,
    ProfileTokensPostRequest,
    ProfileTokensPostResponse,
    ProfileTokensTokenIdDeleteResponse,
    ProfileTokensTokenIdDeleteResponse1,
    ProfileTokensTokenIdGetResponse,
    ProfileTokensTokenIdPutResponse,
    Promotion,
    Region1,
    RegionsGetResponse,
    RegionsGetResponse1,
    RegionsRegionIdGetResponse,
    Rules,
    SecurityQuestionsGet,
    SecurityQuestionsPost,
    ServiceTransfer,
    SSHKey,
    StackScript,
    SupportTicket,
    SupportTicketReply,
    SupportTicketRequest,
    SupportTicketsGetResponse,
    SupportTicketsGetResponse1,
    SupportTicketsPostResponse,
    SupportTicketsTicketIdAttachmentsPostResponse,
    SupportTicketsTicketIdAttachmentsPostResponse1,
    SupportTicketsTicketIdClosePostResponse,
    SupportTicketsTicketIdClosePostResponse1,
    SupportTicketsTicketIdGetResponse,
    SupportTicketsTicketIdRepliesGetResponse,
    SupportTicketsTicketIdRepliesGetResponse1,
    SupportTicketsTicketIdRepliesPostRequest,
    SupportTicketsTicketIdRepliesPostResponse,
    Tag1,
    TagsGetResponse,
    TagsGetResponse1,
    TagsLabelDeleteResponse,
    TagsLabelDeleteResponse1,
    TagsLabelGetResponse,
    TagsLabelGetResponse1,
    TagsPostRequest,
    TagsPostResponse,
    Transfer1,
    TrustedDevice,
    User,
    Volume,
    VolumesGetResponse,
    VolumesGetResponse1,
    VolumesPostRequest,
    VolumesPostResponse,
    VolumesVolumeIdAttachPostRequest,
    VolumesVolumeIdAttachPostResponse,
    VolumesVolumeIdClonePostRequest,
    VolumesVolumeIdClonePostResponse,
    VolumesVolumeIdDeleteResponse,
    VolumesVolumeIdDeleteResponse1,
    VolumesVolumeIdDetachPostResponse,
    VolumesVolumeIdDetachPostResponse1,
    VolumesVolumeIdGetResponse,
    VolumesVolumeIdPutRequest,
    VolumesVolumeIdPutResponse,
    VolumesVolumeIdResizePostRequest,
    VolumesVolumeIdResizePostResponse,
)

app = MCPProxy(
    contact={
        'email': 'support@linode.com',
        'name': 'Linode',
        'url': 'https://linode.com',
    },
    description='## Introduction\nThe Linode API provides the ability to programmatically manage the full\nrange of Linode products and services.\n\nThis reference is designed to assist application developers and system\nadministrators.  Each endpoint includes descriptions, request syntax, and\nexamples using standard HTTP requests. Response data is returned in JSON\nformat.\n\n\nThis document was generated from our OpenAPI Specification.  See the\n<a target="_top" href="https://www.openapis.org">OpenAPI website</a> for more information.\n\n<a target="_top" href="/docs/api/openapi.yaml">Download the Linode OpenAPI Specification</a>.\n\n\n## Changelog\n\n<a target="_top" href="/docs/products/tools/api/release-notes/">View our Changelog</a> to see release\nnotes on all changes made to our API.\n\n## Access and Authentication\n\nSome endpoints are publicly accessible without requiring authentication.\nAll endpoints affecting your Account, however, require either a Personal\nAccess Token or OAuth authentication (when using third-party\napplications).\n\n### Personal Access Token\n\nThe easiest way to access the API is with a Personal Access Token (PAT)\ngenerated from the\n<a target="_top" href="https://cloud.linode.com/profile/tokens">Linode Cloud Manager</a> or\nthe [Create Personal Access Token](/docs/api/profile/#personal-access-token-create) endpoint.\n\nAll scopes for the OAuth security model ([defined below](/docs/api/profile/#oauth)) apply to this\nsecurity model as well.\n\n#### Authentication\n\n| Security Scheme Type: | HTTP |\n|-----------------------|------|\n| **HTTP Authorization Scheme** | bearer |\n\n### OAuth\nIf you only need to access the Linode API for personal use,\nwe recommend that you create a [personal access token](/docs/api/#personal-access-token).\nIf you\'re designing an application that can authenticate with an arbitrary Linode user, then\nyou should use the OAuth 2.0 workflows presented in this section.\n\nFor a more detailed example of an OAuth 2.0 implementation, see our guide on [How to Create an OAuth App with the Linode Python API Library](/docs/products/tools/api/guides/create-an-oauth-app-with-the-python-api-library/#oauth-2-authentication-exchange).\n\nBefore you implement OAuth in your application, you first need to create an OAuth client. You can do this [with the Linode API](/docs/api/account/#oauth-client-create) or [via the Cloud Manager](https://cloud.linode.com/profile/clients):\n\n  - When creating the client, you\'ll supply a `label` and a `redirect_uri` (referred to as the Callback URL in the Cloud Manager).\n  - The response from this endpoint will give you a `client_id` and a `secret`.\n  - Clients can be public or private, and are private by default. You can choose to make the client public when it is created.\n    - A private client is used with applications which can securely store the client secret (that is, the secret returned to you when you first created the client). For example, an application running on a secured server that only the developer has access to would use a private OAuth client. This is also called a confidential client in some OAuth documentation.\n    - A public client is used with applications where the client secret is not guaranteed to be secure. For example, a native app running on a user\'s computer may not be able to keep the client secret safe, as a user could potentially inspect the source of the application. So, native apps or apps that run in a user\'s browser should use a public client.\n    - Public and private clients follow different workflows, as described below.\n\n#### OAuth Workflow\n\nThe OAuth workflow is a series of exchanges between your third-party app and Linode. The workflow is used\nto authenticate a user before an application can start making API calls on the user\'s behalf.\n\nNotes:\n\n- With respect to the diagram in [section 1.2 of RFC 6749](https://tools.ietf.org/html/rfc6749#section-1.2), login.linode.com (referred to in this section as the *login server*)\nis the Resource Owner and the Authorization Server; api.linode.com (referred to here as the *api server*) is the Resource Server.\n- The OAuth spec refers to the private and public workflows listed below as the [authorization code flow](https://tools.ietf.org/html/rfc6749#section-1.3.1) and [implicit flow](https://tools.ietf.org/html/rfc6749#section-1.3.2).\n\n| PRIVATE WORKFLOW | PUBLIC WORKFLOW |\n|------------------|------------------|\n| 1.  The user visits the application\'s website and is directed to login with Linode. | 1.  The user visits the application\'s website and is directed to login with Linode. |\n| 2.  Your application then redirects the user to Linode\'s [login server](https://login.linode.com) with the client application\'s `client_id` and requested OAuth `scope`, which should appear in the URL of the login page. | 2.  Your application then redirects the user to Linode\'s [login server](https://login.linode.com) with the client application\'s `client_id` and requested OAuth `scope`, which should appear in the URL of the login page. |\n| 3.  The user logs into the login server with their username and password. | 3.  The user logs into the login server with their username and password. |\n| 4.  The login server redirects the user to the specificed redirect URL with a temporary authorization `code` (exchange code) in the URL. | 4.  The login server redirects the user back to your application with an OAuth `access_token` embedded in the redirect URL\'s hash. This is temporary and expires in two hours. No `refresh_token` is issued. Therefore, once the `access_token` expires, a new one will need to be issued by having the user log in again. |\n| 5.  The application issues a POST request (*see additional details below*) to the login server with the exchange code, `client_id`, and the client application\'s `client_secret`. | |\n| 6.  The login server responds to the client application with a new OAuth `access_token` and `refresh_token`. The `access_token` is set to expire in two hours. | |\n| 7.  The `refresh_token` can be used by contacting the login server with the `client_id`, `client_secret`, `grant_type`, and `refresh_token` to get a new OAuth `access_token` and `refresh_token`. The new `access_token` is good for another two hours, and the new `refresh_token` can be used to extend the session again by this same method (*see additional details below*). | |\n\n#### OAuth Private Workflow - Additional Details\n\nThe following information expands on steps 5 through 7 of the private workflow:\n\nOnce the user has logged into Linode and you have received an exchange code,\nyou will need to trade that exchange code for an `access_token` and `refresh_token`. You\ndo this by making an HTTP POST request to the following address:\n\n```\nhttps://login.linode.com/oauth/token\n```\n\nMake this request as `application/x-www-form-urlencoded` or as\n`multipart/form-data` and include the following parameters in the POST body:\n\n| PARAMETER | DESCRIPTION |\n|-----------|-------------|\n| client_id | Your app\'s client ID. |\n| client_secret | Your app\'s client secret. |\n| code | The code you just received from the redirect. |\n\nYou\'ll get a response like this:\n\n```json\n{\n  "scope": "linodes:read_write",\n  "access_token": "03d084436a6c91fbafd5c4b20c82e5056a2e9ce1635920c30dc8d81dc7a6665c",\n  "refresh_token": "f2ec9712e616fdb5a2a21aa0e88cfadea7502ebc62cf5bd758dbcd65e1803bad",\n  "token_type": "bearer",\n  "expires_in": 7200\n}\n```\n\nIncluded in the response is an `access_token`. With this token, you can proceed to make\nauthenticated HTTP requests to the API by adding this header to each request:\n\n```\nAuthorization: Bearer 03d084436a6c91fbafd5c4b20c82e5056a2e9ce1635920c30dc8d81dc7a6665c\n```\n\nThis `access_token` is set to expire in two hours. To refresh access prior to expiration, make another request to the same URL with the following parameters in the POST body:\n\n| PARAMETER | DESCRIPTION |\n|-----------|-------------|\n| grant_type | The grant type you\'re using. Use "refresh_token" when refreshing access. |\n| client_id | Your app\'s client ID. |\n| client_secret | Your app\'s client secret. |\n| refresh_token | The `refresh_token` received from the previous response. |\n\nYou\'ll get another response with an updated `access_token` and `refresh_token`, which can then be used to refresh access again.\n\n#### OAuth Reference\n\n| Security Scheme Type | OAuth 2.0 |\n|-----------------------|--------|\n| **Authorization URL** | https://login.linode.com/oauth/authorize |\n| **Token URL** | https://login.linode.com/oauth/token |\n| **Scopes** | <ul><li>`account:read_only` - Allows access to GET information about your Account.</li><li>`account:read_write` - Allows access to all endpoints related to your Account.</li><li>`databases:read_only` - Allows access to GET Managed Databases on your Account.</li><li>`databases:read_write` - Allows access to all endpoints related to your Managed Databases.</li><li>`domains:read_only` - Allows access to GET Domains on your Account.</li><li>`domains:read_write` - Allows access to all Domain endpoints.</li><li>`events:read_only` - Allows access to GET your Events.</li><li>`events:read_write` - Allows access to all endpoints related to your Events.</li><li>`firewall:read_only` - Allows access to GET information about your Firewalls.</li><li>`firewall:read_write` - Allows access to all Firewall endpoints.</li><li>`images:read_only` - Allows access to GET your Images.</li><li>`images:read_write` - Allows access to all endpoints related to your Images.</li><li>`ips:read_only` - Allows access to GET your ips.</li><li>`ips:read_write` - Allows access to all endpoints related to your ips.</li><li>`linodes:read_only` - Allows access to GET Linodes on your Account.</li><li>`linodes:read_write` - Allow access to all endpoints related to your Linodes.</li><li>`lke:read_only` - Allows access to GET LKE Clusters on your Account.</li><li>`lke:read_write` - Allows access to all endpoints related to LKE Clusters on your Account.</li><li>`longview:read_only` - Allows access to GET your Longview Clients.</li><li>`longview:read_write` - Allows access to all endpoints related to your Longview Clients.</li><li>`nodebalancers:read_only` - Allows access to GET NodeBalancers on your Account.</li><li>`nodebalancers:read_write` - Allows access to all NodeBalancer endpoints.</li><li>`object_storage:read_only` - Allows access to GET information related to your Object Storage.</li><li>`object_storage:read_write` - Allows access to all Object Storage endpoints.</li><li>`stackscripts:read_only` - Allows access to GET your StackScripts.</li><li>`stackscripts:read_write` - Allows access to all endpoints related to your StackScripts.</li><li>`volumes:read_only` - Allows access to GET your Volumes.</li><li>`volumes:read_write` - Allows access to all endpoints related to your Volumes.</li></ul><br/>|\n\n## Requests\n\nRequests must be made over HTTPS to ensure transactions are encrypted. The\nfollowing Request methods are supported:\n\n| METHOD | USAGE |\n|--------|-------|\n| GET    | Retrieves data about collections and individual resources. |\n| POST   | For collections, creates a new resource of that type. Also used to perform actions on action endpoints. |\n| PUT    | Updates an existing resource. |\n| DELETE | Deletes a resource. This is a destructive action. |\n\n\n## Responses\n\nActions will return one following HTTP response status codes:\n\n| STATUS  | DESCRIPTION |\n|---------|-------------|\n| 200 OK  | The request was successful. |\n| 202 Accepted | The request was successful, but processing has not been completed. The response body includes a "warnings" array containing the details of incomplete processes. |\n| 204 No Content | The server successfully fulfilled the request and there is no additional content to send. |\n| 299 Deprecated | The request was successful, but involved a deprecated endpoint. The response body includes a "warnings" array containing warning messages. |\n| 400 Bad Request | You submitted an invalid request (missing parameters, etc.). |\n| 401 Unauthorized | You failed to authenticate for this resource. |\n| 403 Forbidden | You are authenticated, but don\'t have permission to do this. |\n| 404 Not Found | The resource you\'re requesting does not exist. |\n| 429 Too Many Requests | You\'ve hit a rate limit. |\n| 500 Internal Server Error | Please [open a Support Ticket](/docs/api/support/#support-ticket-open). |\n\n## Errors\n\nSuccess is indicated via <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_top">Standard HTTP status codes</a>.\n`2xx` codes indicate success, `4xx` codes indicate a request error, and\n`5xx` errors indicate a server error. A\nrequest error might be an invalid input, a required parameter being omitted,\nor a malformed request. A server error means something went wrong processing\nyour request. If this occurs, please\n[open a Support Ticket](/docs/api/support/#support-ticket-open)\nand let us know. Though errors are logged and we work quickly to resolve issues,\nopening a ticket and providing us with reproducable steps and data is always helpful.\n\nThe `errors` field is an array of the things that went wrong with your request.\nWe will try to include as many of the problems in the response as possible,\nbut it\'s conceivable that fixing these errors and resubmitting may result in\nnew errors coming back once we are able to get further along in the process\nof handling your request.\n\n\nWithin each error object, the `field` parameter will be included if the error\npertains to a specific field in the JSON you\'ve submitted. This will be\nomitted if there is no relevant field. The `reason` is a human-readable\nexplanation of the error, and will always be included.\n\n## Pagination\n\nResource lists are always paginated. The response will look similar to this:\n\n```json\n{\n    "data": [ ... ],\n    "page": 1,\n    "pages": 3,\n    "results": 300\n}\n```\n\n* Pages start at 1. You may retrieve a specific page of results by adding\n`?page=x` to your URL (for example, `?page=4`). If the value of `page`\nexceeds `2^64/page_size`, the last possible page will be returned.\n\n\n* Page sizes default to 100,\nand can be set to return between 25 and 500. Page size can be set using\n`?page_size=x`.\n\n## Filtering and Sorting\n\nCollections are searchable by fields they include, marked in the spec as\n`x-linode-filterable: true`. Filters are passed\nin the `X-Filter` header and are formatted as JSON objects. Here is a request\ncall for Linode Types in our "standard" class:\n\n```Shell\ncurl "https://api.linode.com/v4/linode/types" \\\n  -H \'X-Filter: { "class": "standard" }\'\n```\n\nThe filter object\'s keys are the keys of the object you\'re filtering,\nand the values are accepted values. You can add multiple filters by\nincluding more than one key. For example, filtering for "standard" Linode\nTypes that offer one vcpu:\n\n```Shell\n curl "https://api.linode.com/v4/linode/types" \\\n  -H \'X-Filter: { "class": "standard", "vcpus": 1 }\'\n```\n\nIn the above example, both filters are combined with an "and" operation.\nHowever, if you wanted either Types with one vcpu or Types in our "standard"\nclass, you can add an operator:\n\n ```Shell\ncurl "https://api.linode.com/v4/linode/types" \\\n  -H \'X-Filter: { "+or": [ { "vcpus": 1 }, { "class": "standard" } ] }\'\n```\n\nEach filter in the `+or` array is its own filter object, and all conditions\nin it are combined with an "and" operation as they were in the previous example.\n\nOther operators are also available. Operators are keys of a Filter JSON\nobject. Their value must be of the appropriate type, and they are evaluated\nas described below:\n\n| OPERATOR | TYPE   | DESCRIPTION                       |\n|----------|--------|-----------------------------------|\n| +and     | array  | All conditions must be true.       |\n| +or      | array  | One condition must be true.        |\n| +gt      | number | Value must be greater than number. |\n| +gte     | number | Value must be greater than or equal to number. |\n| +lt      | number | Value must be less than number. |\n| +lte     | number | Value must be less than or equal to number. |\n| +contains | string | Given string must be in the value. |\n| +neq      | string | Does not equal the value.          |\n| +order_by | string | Attribute to order the results by - must be filterable. |\n| +order    | string | Either "asc" or "desc". Defaults to "asc". Requires `+order_by`. |\n\nFor example, filtering for [Linode Types](/docs/api/linode-types/)\nthat offer memory equal to or higher than 61440:\n\n```Shell\ncurl "https://api.linode.com/v4/linode/types" \\\n  -H \'\n    X-Filter: {\n      "memory": {\n        "+gte": 61440\n      }\n    }\'\n```\n\nYou can combine and nest operators to construct arbitrarily-complex queries.\nFor example, give me all [Linode Types](/docs/api/linode-types/)\nwhich are either `standard` or `highmem` class, or\nhave between 12 and 20 vcpus:\n\n```Shell\ncurl "https://api.linode.com/v4/linode/types" \\\n  -H \'\n    X-Filter: {\n      "+or": [\n        {\n          "+or": [\n            {\n              "class": "standard"\n            },\n            {\n              "class": "highmem"\n            }\n          ]\n        },\n        {\n          "+and": [\n            {\n              "vcpus": {\n                "+gte": 12\n              }\n            },\n            {\n              "vcpus": {\n                "+lte": 20\n              }\n            }\n          ]\n        }\n      ]\n    }\'\n```\n## Time Values\n\nAll times returned by the API are in UTC, regardless of the timezone configured within your user\'s profile (see `timezone` property within [Profile View](/docs/api/profile/#profile-view__responses)).\n\n## Rate Limiting\n\nRate limits on API requests help maintain the health and stability of the Linode API. Accordingly, every endpoint of the Linode API applies a rate limit on a per user basis as determined by OAuth token for authenticated requests or IP address for public endpoints.\n\nEach rate limit consists of a total number of requests and a time window. For example, if an endpoint has a rate limit of 800 requests per minute, then up to 800 requests over a one minute window are permitted. Subsequent requests to an endpoint after hitting a rate limit return a 429 error. You can successfully remake requests to that endpoint after the rate limit window resets.\n\n### Linode APIv4 Rate Limits\n\nWith the Linode API, you can generally make up to 1,600 general API requests every two minutes. Additionally, all endpoints have a rate limit of 800 requests per minute unless otherwise specified below.\n\n**Note:** There may be rate limiting applied at other levels outside of the API, for example, at the load balancer.\n\nCreating Linodes has a dedicated rate limit of 10 requests per 30 seconds. That endpoint is:\n\n* [Linode Create](/docs/api/linode-instances/#linode-create)\n\n`/stats` endpoints have their own dedicated rate limits of 100 requests per minute. These endpoints are:\n\n* [View Linode Statistics](/docs/api/linode-instances/#linode-statistics-view)\n* [View Linode Statistics (year/month)](/docs/api/linode-instances/#statistics-yearmonth-view)\n* [View NodeBalancer Statistics](/docs/api/nodebalancers/#nodebalancer-statistics-view)\n* [List Managed Stats](/docs/api/managed/#managed-stats-list)\n\nObject Storage endpoints have a dedicated rate limit of 750 requests per second. The Object Storage endpoints are:\n\n* [Object Storage Endpoints](/docs/api/object-storage/)\n\nOpening Support Tickets has a dedicated rate limit of 2 requests per minute. That endpoint is:\n\n* [Open Support Ticket](/docs/api/support/#support-ticket-open)\n\nAccepting Service Transfers has a dedicated rate limit of 2 requests per minute. That endpoint is:\n\n* [Service Transfer Accept](/docs/api/account/#service-transfer-accept)\n\n### Rate Limit HTTP Response Headers\n\nThe Linode API includes the following HTTP response headers which are designed to help you avoid hitting rate limits that might disrupt your applications:\n\n* **X-RateLimit-Limit**: The maximum number of permitted requests during the rate limit window for this endpoint.\n* **X-RateLimit-Remaining**: The remaining number of permitted requests in the current rate limit window.\n* **X-RateLimit-Reset**: The time when the current rate limit window rests in UTC epoch seconds.\n* **Retry-After**: The remaining time in seconds until the current rate limit window resets.\n\nThere are many ways to access header information for your requests, depending on how you are accessing the Linode API. For example, to view HTTP response headers when making requests with `curl`, use the `-i` or `--include` option as follows:\n\n```Shell\ncurl -i https://api.linode.com/v4/regions\n```\n\n## CLI (Command Line Interface)\n\nThe <a href="https://github.com/linode/linode-cli" target="_top">Linode CLI</a> allows you to easily\nwork with the API using intuitive and simple syntax. It requires a\n[Personal Access Token](/docs/api/#personal-access-token)\nfor authentication, and gives you access to all of the features and functionality\nof the Linode API that are documented here with CLI examples.\n\nEndpoints that do not have CLI examples are currently unavailable through the CLI, but\ncan be accessed via other methods such as Shell commands and other third-party applications.\n',
    title='Linode API',
    version='4.145.0',
    servers=[
        {'url': 'https://api.linode.com/v4'},
        {'url': 'https://api.linode.com/v4beta'},
    ],
)


@app.get(
    '/account',
    description=""" Returns the contact and billing information related to your Account.
 """,
    tags=[
        'account_management',
        'account_settings_management',
        'user_profile_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_account():
    """
    Account View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account',
    description=""" Updates contact and billing information related to your Account.
 """,
    tags=['account_management', 'account_settings_management', 'user_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_account(body: Account):
    """
    Account Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/cancel',
    description=""" Cancels an active Linode account. This action will cause Linode to attempt to charge the credit card on file for the remaining balance. An error will occur if Linode fails to charge the credit card on file. Restricted users will not be able to cancel an account.
 """,
    tags=['account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def cancel_account(body: AccountCancelPostRequest):
    """
    Account Cancel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/credit-card',
    description=""" **DEPRECATED**. Please use Payment Method Add ([POST /account/payment-methods](/docs/api/account/#payment-method-add)).

Adds a credit card Payment Method to your account and sets it as the default method.
 """,
    tags=['credit_card_management', 'payment_method_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_credit_card(body: CreditCard1):
    """
    Credit Card Add/Edit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/entity-transfers',
    description=""" **DEPRECATED**. Please use [Service Transfers List](/docs/api/account/#service-transfers-list).
 """,
    tags=['entity_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_entity_transfers(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Entity Transfers List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/entity-transfers',
    description=""" **DEPRECATED**. Please use [Service Transfer Create](/docs/api/account/#service-transfer-create).
 """,
    tags=['entity_transfer_operations', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_entity_transfer(body: AccountEntityTransfersPostRequest = None):
    """
    Entity Transfer Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/account/entity-transfers/{token}',
    description=""" **DEPRECATED**. Please use [Service Transfer Cancel](/docs/api/account/#service-transfer-cancel).
 """,
    tags=['entity_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_entity_transfer(token: UUID):
    """
    Entity Transfer Cancel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/entity-transfers/{token}',
    description=""" **DEPRECATED**. Please use [Service Transfer View](/docs/api/account/#service-transfer-view).
 """,
    tags=['entity_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_entity_transfer(token: UUID):
    """
    Entity Transfer View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/entity-transfers/{token}/accept',
    description=""" **DEPRECATED**. Please use [Service Transfer Accept](/docs/api/account/#service-transfer-accept).
 """,
    tags=['entity_transfer_operations', 'service_transfer_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def accept_entity_transfer(token: UUID):
    """
    Entity Transfer Accept
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/events',
    description=""" Returns a collection of Event objects representing actions taken on your Account from the last 90 days. The Events returned depend on your grants.
 """,
    tags=['event_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_events(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Events List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/events/{eventId}',
    description=""" Returns a single Event object.
 """,
    tags=['event_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_event(event_id: int = Path(..., alias='eventId')):
    """
    Event View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/events/{eventId}/read',
    description=""" Marks a single Event as read. """,
    tags=['event_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def event_read(event_id: int = Path(..., alias='eventId')):
    """
    Event Mark as Read
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/events/{eventId}/seen',
    description=""" Marks all Events up to and including this Event by ID as seen.
 """,
    tags=['event_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def event_seen(event_id: int = Path(..., alias='eventId')):
    """
    Event Mark as Seen
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/invoices',
    description=""" Returns a paginated list of Invoices against your Account.
 """,
    tags=['invoice_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_invoices(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Invoices List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/invoices/{invoiceId}',
    description=""" Returns a single Invoice object. """,
    tags=['invoice_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_invoice(invoice_id: int = Path(..., alias='invoiceId')):
    """
    Invoice View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/invoices/{invoiceId}/items',
    description=""" Returns a paginated list of Invoice items. """,
    tags=['invoice_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_invoice_items(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    invoice_id: int = Path(..., alias='invoiceId'),
):
    """
    Invoice Items List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/logins',
    description=""" Returns a collection of successful logins for all users on the account during the last 90 days. This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['user_login_management', 'profile_login_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_account_logins():
    """
    User Logins List All
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/logins/{loginId}',
    description=""" Returns a Login object that displays information about a successful login. The logins that can be viewed can be for any user on the account, and are not limited to only the logins of the user that is accessing this API endpoint. This command can only be accessed by the unrestricted users of the account.
 """,
    tags=['user_login_management', 'profile_login_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_account_login(login_id: int = Path(..., alias='loginId')):
    """
    Login View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/maintenance',
    description=""" Returns a collection of Maintenance objects for any entity a user has permissions to view. Cancelled Maintenance objects are not returned.

Currently, Linodes are the only entities available for viewing.
 """,
    tags=['managed_issue_tracking', 'user_management', 'ticket_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_maintenance():
    """
    Maintenance List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/notifications',
    description=""" Returns a collection of Notification objects representing important, often time-sensitive items related to your Account.
You cannot interact directly with Notifications, and a Notification will disappear when the circumstances causing it have been resolved. For example, if you have an important Ticket open, you must respond to the Ticket to dismiss the Notification.
 """,
    tags=['notification_handling'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_notifications():
    """
    Notifications List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/oauth-clients',
    description=""" Returns a paginated list of OAuth Clients registered to your Account.  OAuth Clients allow users to log into applications you write or host using their Linode Account, and may allow them to grant some level of access to their Linodes or other entities to your application.
 """,
    tags=['oauth_client_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_clients(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    OAuth Clients List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/oauth-clients',
    description=""" Creates an OAuth Client, which can be used to allow users (using their Linode account) to log in to your own application, and optionally grant your application some amount of access to their Linodes or other entities.
 """,
    tags=['oauth_client_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_client(body: AccountOauthClientsPostRequest = None):
    """
    OAuth Client Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/account/oauth-clients/{clientId}',
    description=""" Deletes an OAuth Client registered with Linode. The Client ID and Client secret will no longer be accepted by <a target="_top" href="https://login.linode.com">https://login.linode.com</a>, and all tokens issued to this client will be invalidated (meaning that if your application was using a token, it will no longer work).
 """,
    tags=['oauth_client_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_client(client_id: str = Path(..., alias='clientId')):
    """
    OAuth Client Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/oauth-clients/{clientId}',
    description=""" Returns information about a single OAuth client.
 """,
    tags=['oauth_client_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_client(client_id: str = Path(..., alias='clientId')):
    """
    OAuth Client View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/oauth-clients/{clientId}',
    description=""" Update information about an OAuth Client on your Account. This can be especially useful to update the `redirect_uri` of your client in the event that the callback url changed in your application.
 """,
    tags=['oauth_client_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_client(
    client_id: str = Path(..., alias='clientId'), body: OAuthClient = None
):
    """
    OAuth Client Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/oauth-clients/{clientId}/reset-secret',
    description=""" Resets the OAuth Client secret for a client you own, and returns the OAuth Client with the plaintext secret. This secret is not supposed to be publicly known or disclosed anywhere. This can be used to generate a new secret in case the one you have has been leaked, or to get a new secret if you lost the original. The old secret is expired immediately, and logins to your client with the old secret will fail.
 """,
    tags=['oauth_client_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def reset_client_secret(client_id: str = Path(..., alias='clientId')):
    """
    OAuth Client Secret Reset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/oauth-clients/{clientId}/thumbnail',
    description=""" Returns the thumbnail for this OAuth Client.  This is a publicly-viewable endpoint, and can be accessed without authentication.
 """,
    tags=['oauth_client_management'],
)
def get_client_thumbnail(client_id: str = Path(..., alias='clientId')):
    """
    OAuth Client Thumbnail View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/oauth-clients/{clientId}/thumbnail',
    description=""" Upload a thumbnail for a client you own.  You must upload an image file that will be returned when the thumbnail is retrieved.  This image will be publicly-viewable.
 """,
    tags=['oauth_client_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def set_client_thumbnail(client_id: str = Path(..., alias='clientId')):
    """
    OAuth Client Thumbnail Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/payment-methods',
    description=""" Returns a paginated list of Payment Methods for this Account.
 """,
    tags=['payment_method_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_payment_methods(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Payment Methods List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/payment-methods',
    description=""" Adds a Payment Method to your Account with the option to set it as the default method.

* Adding a default Payment Method removes the default status from any other Payment Method.

* An Account can have up to 6 active Payment Methods.

* Up to 60 Payment Methods can be added each day.

* Prior to adding a Payment Method, ensure that your billing address information is up-to-date
with a valid `zip` by using the Account Update ([PUT /account](/docs/api/account/#account-update)) endpoint.

* A `payment_method_add` event is generated when a payment is successfully submitted.
 """,
    tags=['payment_method_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_payment_method(body: AccountPaymentMethodsPostRequest):
    """
    Payment Method Add
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/account/payment-methods/{paymentMethodId}',
    description=""" Deactivate the specified Payment Method.

The default Payment Method can not be deleted. To add a new default Payment Method, access the Payment Method
Add ([POST /account/payment-methods](/docs/api/account/#payment-method-add)) endpoint. To designate an existing
Payment Method as the default method, access the Payment Method Make Default
([POST /account/payment-methods/{paymentMethodId}/make-default](/docs/api/account/#payment-method-make-default))
endpoint.
 """,
    tags=['payment_method_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_payment_method(payment_method_id: int = Path(..., alias='paymentMethodId')):
    """
    Payment Method Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/payment-methods/{paymentMethodId}',
    description=""" View the details of the specified Payment Method.
 """,
    tags=['payment_method_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_payment_method(payment_method_id: int = Path(..., alias='paymentMethodId')):
    """
    Payment Method View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/payment-methods/{paymentMethodId}/make-default',
    description=""" Make the specified Payment Method the default method for automatically processing payments.

Removes the default status from any other Payment Method.
 """,
    tags=['payment_method_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def make_payment_method_default(
    payment_method_id: int = Path(..., alias='paymentMethodId')
):
    """
    Payment Method Make Default
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/payments',
    description=""" Returns a paginated list of Payments made on this Account.
 """,
    tags=['payment_processing', 'payment_method_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_payments(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Payments List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/payments',
    description=""" Makes a Payment to your Account.

* The requested amount is charged to the default Payment Method if no `payment_method_id` is specified.

* A `payment_submitted` event is generated when a payment is successfully submitted.
 """,
    tags=['payment_processing', 'payment_method_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_payment(body: PaymentRequest):
    """
    Payment Make
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/payments/paypal',
    description=""" **Note**: This endpoint is disabled and no longer accessible. PayPal can be designated as a Payment Method for automated payments using the Cloud Manager. See [Manage Payment Methods](/docs/products/platform/billing/guides/payment-methods/).
 """,
    tags=['payment_processing', 'payment_method_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_pay_pal_payment(body: PayPal):
    """
    PayPal Payment Stage
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/payments/paypal/execute',
    description=""" **Note**: This endpoint is disabled and no longer accessible. PayPal can be designated as a Payment Method for automated payments using the Cloud Manager. See [Manage Payment Methods](/docs/products/platform/billing/guides/payment-methods/).
 """,
    tags=['payment_processing', 'payment_method_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def execute_pay_pal_payment(body: PayPalExecute):
    """
    Staged/Approved PayPal Payment Execute
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/payments/{paymentId}',
    description=""" Returns information about a specific Payment.
 """,
    tags=['payment_processing', 'invoice_management', 'payment_method_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_payment(payment_id: int = Path(..., alias='paymentId')):
    """
    Payment View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/promo-codes',
    description=""" Adds an expiring Promo Credit to your account.

The following restrictions apply:

* Your account must be less than 90 days old.
* There must not be an existing Promo Credit already on your account.
* The requesting User must be unrestricted. Use the User Update
  ([PUT /account/users/{username}](/docs/api/account/#user-update)) to change a User's restricted status.
* The `promo_code` must be valid and unexpired.
 """,
    tags=['account_management', 'payment_method_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_promo_credit(body: AccountPromoCodesPostRequest = None):
    """
    Promo Credit Add
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/service-transfers',
    description=""" Returns a collection of all created and accepted Service Transfers for this account, regardless of the user that created or accepted the transfer.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['entity_transfer_operations', 'service_transfer_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_service_transfers(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Service Transfers List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/service-transfers',
    description=""" Creates a transfer request for the specified services. A request can contain any of the specified service types
and any number of each service type. At this time, only Linodes can be transferred.

When created successfully, a confirmation email is sent to the account that created this transfer containing a
transfer token and instructions on completing the transfer.

When a transfer is [accepted](/docs/api/account/#service-transfer-accept), the requested services are moved to
the receiving account. Linode services will not experience interruptions due to the transfer process. Backups
for Linodes are transferred as well.

DNS records that are associated with requested services will not be transferred or updated. Please ensure that
associated DNS records have been updated or communicated to the recipient prior to the transfer.

A transfer can take up to three hours to complete once accepted. When a transfer is
completed, billing for transferred services ends for the sending account and begins for the receiving account.

This command can only be accessed by the unrestricted users of an account.

There are several conditions that must be met in order to successfully create a transfer request:

1. The account creating the transfer must not have a past due balance or active Terms of Service violation.

1. The service must be owned by the account that is creating the transfer.

1. The service must not be assigned to another Service Transfer that is pending or that has been accepted and is
incomplete.

1. Linodes must not:

    * be assigned to a NodeBalancer, Firewall, VLAN, or Managed Service.

    * have any attached Block Storage Volumes.

    * have any shared IP addresses.

    * have any assigned /56, /64, or /116 IPv6 ranges.
 """,
    tags=['service_transfer_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_service_transfer(body: AccountServiceTransfersPostRequest = None):
    """
    Service Transfer Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/account/service-transfers/{token}',
    description=""" Cancels the Service Transfer for the provided token. Once cancelled, a transfer cannot be accepted or otherwise
acted on in any way. If cancelled in error, the transfer must be
[created](/docs/api/account/#service-transfer-create) again.

When cancelled, an email notification for the cancellation is sent to the account that created
this transfer. Transfers can not be cancelled if they are expired or have been accepted.

This command can only be accessed by the unrestricted users of the account that created this transfer.
 """,
    tags=['entity_transfer_operations', 'service_transfer_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_service_transfer(token: UUID):
    """
    Service Transfer Cancel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/service-transfers/{token}',
    description=""" Returns the details of the Service Transfer for the provided token.

While a transfer is pending, any unrestricted user *of any account* can access this command. After a
transfer has been accepted, it can only be viewed by unrestricted users of the accounts that created and
accepted the transfer. If cancelled or expired, only unrestricted users of the account that created the
transfer can view it.
 """,
    tags=['service_transfer_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_service_transfer(token: UUID):
    """
    Service Transfer View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/service-transfers/{token}/accept',
    description=""" Accept a Service Transfer for the provided token to receive the services included in the transfer to your
account. At this time, only Linodes can be transferred.

When accepted, email confirmations are sent to the accounts that created and accepted the transfer. A transfer
can take up to three hours to complete once accepted. Once a transfer is completed, billing for transferred
services ends for the sending account and begins for the receiving account.

This command can only be accessed by the unrestricted users of the account that receives the transfer. Users
of the same account that created a transfer cannot accept the transfer.

There are several conditions that must be met in order to accept a transfer request:

1. Only transfers with a `pending` status can be accepted.

1. The account accepting the transfer must have a registered payment method and must not have a past due
  balance or other account limitations for the services to be transferred.

1. Both the account that created the transfer and the account that is accepting the transfer must not have any
active Terms of Service violations.

1. The service must still be owned by the account that created the transfer.

1. Linodes must not:

    * be assigned to a NodeBalancer, Firewall, VLAN, or Managed Service.

    * have any attached Block Storage Volumes.

    * have any shared IP addresses.

    * have any assigned /56, /64, or /116 IPv6 ranges.

Any and all of the above conditions must be cured and maintained by the relevant account prior to the
transfer's expiration to allow the transfer to be accepted by the receiving account.
 """,
    tags=['service_transfer_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def accept_service_transfer(token: UUID):
    """
    Service Transfer Accept
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/settings',
    description=""" Returns information related to your Account settings: Managed service subscription, Longview subscription, and network helper.
 """,
    tags=['account_settings_management', 'user_preferences_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_account_settings():
    """
    Account Settings View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/settings',
    description=""" Updates your Account settings.

To update your Longview subscription plan, send a request to [Update Longview Plan](/docs/api/longview/#longview-plan-update).
 """,
    tags=['account_management', 'account_settings_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_account_settings(body: AccountSettings):
    """
    Account Settings Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/settings/managed-enable',
    description=""" Enables Linode Managed for the entire account and sends a welcome email to the account's associated email address. Linode Managed can monitor any service or software stack reachable over TCP or HTTP. See our [Linode Managed guide](/docs/guides/linode-managed/) to learn more.
 """,
    tags=['linode_management', 'managed_linode_settings_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def enable_account_managed():
    """
    Linode Managed Enable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/transfer',
    description=""" Returns a Transfer object showing your network utilization, in GB, for the current month.
 """,
    tags=['linode_statistics'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_transfer():
    """
    Network Utilization View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/users',
    description=""" Returns a paginated list of Users on your Account.

This command can only be accessed by the unrestricted users of an account.

Users may access all or part of your Account based on their restricted status and grants.  An unrestricted User may access everything on the account, whereas restricted User may only access entities or perform actions they've been given specific grants to.
 """,
    tags=['user_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Users List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account/users',
    description=""" Creates a User on your Account. Once created, a confirmation message containing
password creation and login instructions is sent to the User's email address.

This command can only be accessed by the unrestricted users of an account.

The User's account access is determined by whether or not they are restricted,
and what grants they have been given.
 """,
    tags=['account_management', 'user_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_user(body: AccountUsersPostRequest = None):
    """
    User Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/account/users/{username}',
    description=""" Deletes a User. The deleted User will be immediately logged out and
may no longer log in or perform any actions. All of the User's Grants
will be removed.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['user_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_user(username: str):
    """
    User Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/users/{username}',
    description=""" Returns information about a single User on your Account.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['user_management', 'user_profile_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_user(username: str):
    """
    User View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/users/{username}',
    description=""" Update information about a User on your Account. This can be used to
change the restricted status of a User. When making a User restricted,
no grants will be configured by default and you must then set up grants
in order for the User to access anything on the Account.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=[
        'user_management',
        'account_management',
        'user_profile_management',
        'user_preferences_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_user(username: str, body: User = None):
    """
    User Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account/users/{username}/grants',
    description=""" Returns the full grants structure for the specified account User
(other than the account owner, see below for details). This includes all entities
on the Account alongside the level of access this User has to each of them.

This command can only be accessed by the unrestricted users of an account.

The current authenticated User, including the account owner, may view their
own grants at the [/profile/grants](/docs/api/profile/#grants-list)
endpoint, but will not see entities that they do not have access to.
 """,
    tags=['user_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_user_grants(username: str):
    """
    User's Grants View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/account/users/{username}/grants',
    description=""" Update the grants a User has. This can be used to give a User access
to new entities or actions, or take access away.  You do not need to
include the grant for every entity on the Account in this request; any
that are not included will remain unchanged.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['user_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_user_grants(username: str, body: GrantsResponse = ...):
    """
    User's Grants Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/engines',
    description=""" Display all available Managed Database engine types and versions. Engine IDs are used when creating new Managed Databases.
 """,
    tags=['managed_database_operations', 'database_type_management'],
)
def get_databases_engines(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Managed Database Engines List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/engines/{engineId}',
    description=""" Display information for a single Managed Database engine type and version.
 """,
    tags=['managed_database_operations', 'database_type_management'],
)
def get_databases_engine(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    engine_id: str = Path(..., alias='engineId'),
):
    """
    Managed Database Engine View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/instances',
    description=""" Display all Managed Databases that are accessible by your User, regardless of engine type.

For more detailed information on a particular Database instance, make a request to its `instance_uri`.
 """,
    tags=['managed_database_operations', 'database_type_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_instances(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Managed Databases List All
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mongodb/instances',
    description=""" Display all accessible Managed MongoDB Databases.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=[
        'managed_database_operations',
        'mongo_database_operations',
        'database_type_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_mongo_d_b_instances(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Managed MongoDB Databases List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/databases/mongodb/instances/{instanceId}',
    description=""" Remove a Managed MongoDB Database from your Account.

Requires `read_write` access to the Database.

The Database must have an `active`, `failed`, or `degraded` status to perform this command.

Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=['managed_database_operations', 'mongo_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_databases_mongo_d_b_instance(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed MongoDB Database Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mongodb/instances/{instanceId}',
    description=""" Display information for a single, accessible Managed MongoDB Database.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=['managed_database_operations', 'mongo_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_mongo_d_b_instance(instance_id: int = Path(..., alias='instanceId')):
    """
    Managed MongoDB Database View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/databases/mongodb/instances/{instanceId}',
    description=""" Update a Managed MongoDB Database.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this command.

Updating addresses in the `allow_list` overwrites any existing addresses.

* IP addresses and ranges on this list can access the Managed Database. All other sources are blocked.

* If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.

* Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.

* **Note**: Updates to the `allow_list` may take a short period of time to complete, making this command inappropriate for rapid successive updates to this property.

All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed MongoDB Database. The maintenance window for these updates is configured with the Managed Database's `updates` property.

* If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.

* **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=['managed_database_operations', 'mongo_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def put_databases_mongo_d_b_instance(
    instance_id: int = Path(..., alias='instanceId'),
    body: DatabasesMongodbInstancesInstanceIdPutRequest = ...,
):
    """
    Managed MongoDB Database Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mongodb/instances/{instanceId}/backups',
    description=""" Display all backups for an accessible Managed MongoDB Database.

The Database must not be provisioning to perform this command.

Database `auto` type backups are created every 24 hours at 0:00 UTC. Each `auto` backup is retained for 7 days.

Database `snapshot` type backups are created by accessing the **Managed MongoDB Database Backup Snapshot Create** ([POST /databases/mongodb/instances/{instanceId}/backups](/docs/api/databases/#managed-mongodb-database-backup-snapshot-create)) command.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=['managed_database_operations', 'mongo_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_mongo_d_b_instance_backups(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    instance_id: int = Path(..., alias='instanceId'),
):
    """
    Managed MongoDB Database Backups List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/mongodb/instances/{instanceId}/backups',
    description=""" Creates a snapshot backup of a Managed MongoDB Database.

Requires `read_write` access to the Database.

Up to 3 snapshot backups for each Database can be stored at a time. If 3 snapshots have been created for a Database, one must be deleted before another can be made.

Backups generated by this command have the type `snapshot`. Snapshot backups may take several minutes to complete, after which they will be accessible to view or restore.

The Database must have an `active` status to perform this command. If another backup is in progress, it must complete before a new backup can be initiated.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=[
        'managed_database_operations',
        'mongo_database_operations',
        'backup_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_mongo_d_b_instance_backup(
    instance_id: int = Path(..., alias='instanceId'),
    body: DatabaseBackupSnapshot = None,
):
    """
    Managed MongoDB Database Backup Snapshot Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/databases/mongodb/instances/{instanceId}/backups/{backupId}',
    description=""" Delete a single backup for an accessible Managed MongoDB Database.

Requires `read_write` access to the Database.

The Database must not be provisioning to perform this command.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=[
        'managed_database_operations',
        'mongo_database_operations',
        'backup_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_database_mongo_d_b_instance_backup(
    instance_id: int = Path(..., alias='instanceId'),
    backup_id: int = Path(..., alias='backupId'),
):
    """
    Managed MongoDB Database Backup Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mongodb/instances/{instanceId}/backups/{backupId}',
    description=""" Display information for a single backup for an accessible Managed MongoDB Database.

The Database must not be provisioning to perform this command.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=['managed_database_operations', 'mongo_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_mongo_d_b_instance_backup(
    instance_id: int = Path(..., alias='instanceId'),
    backup_id: int = Path(..., alias='backupId'),
):
    """
    Managed MongoDB Database Backup View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/mongodb/instances/{instanceId}/backups/{backupId}/restore',
    description=""" Restore a backup to a Managed MongoDB Database on your Account.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this command.

**Note**: Restoring from a backup will erase all existing data on the database instance and replace it with backup data.

**Note**: Currently, restoring a backup after resetting Managed Database credentials results in a failed cluster. Please contact Customer Support if this occurs.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=[
        'managed_database_operations',
        'mongo_database_operations',
        'backup_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_mongo_d_b_instance_backup_restore(
    instance_id: int = Path(..., alias='instanceId'),
    backup_id: int = Path(..., alias='backupId'),
):
    """
    Managed MongoDB Database Backup Restore
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mongodb/instances/{instanceId}/credentials',
    description=""" Display the root username and password for an accessible Managed MongoDB Database.

The Database must have an `active` status to perform this command.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=['managed_database_operations', 'mongo_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_mongo_d_b_instance_credentials(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed MongoDB Database Credentials View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/mongodb/instances/{instanceId}/credentials/reset',
    description=""" Reset the root password for a Managed MongoDB Database.

Requires `read_write` access to the Database.

A new root password is randomly generated and accessible with the **Managed MongoDB Database Credentials View** ([GET /databases/mongodb/instances/{instanceId}/credentials](/docs/api/databases/#managed-mongodb-database-credentials-view)) command.

Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.

**Note**: Note that it may take several seconds for credentials to reset.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=['managed_database_operations', 'mongo_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_mongo_d_b_instance_credentials_reset(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed MongoDB Database Credentials Reset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/mongodb/instances/{instanceId}/patch',
    description=""" Apply security patches and updates to the underlying operating system of the Managed MongoDB Database. This function runs during regular maintenance windows, which are configurable with the **Managed MongoDB Database Update** ([PUT /databases/mongodb/instances/{instanceId}](/docs/api/databases/#managed-mongodb-database-update)) command.
Requires `read_write` access to the Database.

The Database must have an `active` status to perform this command.

**Note**:

* If your database cluster is configured with a single node, you will experience downtime during this maintenance. Consider upgrading to a high availability plan to avoid any downtime due to maintenance.

* **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=['managed_database_operations', 'mongo_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_mongo_d_b_instance_patch(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed MongoDB Database Patch
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mongodb/instances/{instanceId}/ssl',
    description=""" Display the SSL CA certificate for an accessible Managed MongoDB Database.

The Database must have an `active` status to perform this command.

**Note**: New MongoDB Databases cannot currently be created.
 """,
    tags=['managed_database_operations', 'mongo_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_mongo_d_b_instance_s_s_l(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed MongoDB Database SSL Certificate View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mysql/instances',
    description=""" Display all accessible Managed MySQL Databases.
 """,
    tags=[
        'managed_database_operations',
        'mysql_database_operations',
        'database_type_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_my_s_q_l_instances(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Managed MySQL Databases List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/mysql/instances',
    description=""" Provision a Managed MySQL Database.

Restricted Users must have the `add_databases` grant to use this command.

New instances can take approximately 15 to 30 minutes to provision.

The `allow_list` is used to control access to the Managed Database.

* IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.

* If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.

* Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.

All Managed Databases include automatic, daily backups. Up to seven backups are automatically stored for each Managed Database, providing restore points for each day of the past week.

All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed MySQL Database during configurable maintenance windows.

* If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.

* **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then [migrate your databases](/docs/products/databases/managed-databases/guides/migrate-mysql/) from the original Managed Database cluster to the new one.

* To modify update the maintenance window for a Database, use the **Managed MySQL Database Update** ([PUT /databases/mysql/instances/{instanceId}](/docs/api/databases/#managed-mysql-database-update)) command.
 """,
    tags=['mysql_database_operations', 'managed_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_my_s_q_l_instances(body: DatabaseMySQLRequest):
    """
    Managed MySQL Database Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/databases/mysql/instances/{instanceId}',
    description=""" Remove a Managed MySQL Database from your Account.

Requires `read_write` access to the Database.

The Database must have an `active`, `failed`, or `degraded` status to perform this command.

Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.
 """,
    tags=['mysql_database_operations', 'managed_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_databases_my_s_q_l_instance(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed MySQL Database Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mysql/instances/{instanceId}',
    description=""" Display information for a single, accessible Managed MySQL Database.
 """,
    tags=['managed_database_operations', 'mysql_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_my_s_q_l_instance(instance_id: int = Path(..., alias='instanceId')):
    """
    Managed MySQL Database View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/databases/mysql/instances/{instanceId}',
    description=""" Update a Managed MySQL Database.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this command.

Updating addresses in the `allow_list` overwrites any existing addresses.

* IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.

* If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.

* Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.

* **Note**: Updates to the `allow_list` may take a short period of time to complete, making this command inappropriate for rapid successive updates to this property.

All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed MySQL Database. The maintenance window for these updates is configured with the Managed Database's `updates` property.

* If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.

* **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then [migrate your databases](/docs/products/databases/managed-databases/guides/migrate-mysql/) from the original Managed Database cluster to the new one.
 """,
    tags=['mysql_database_operations', 'managed_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def put_databases_my_s_q_l_instance(
    instance_id: int = Path(..., alias='instanceId'),
    body: DatabasesMysqlInstancesInstanceIdPutRequest = ...,
):
    """
    Managed MySQL Database Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mysql/instances/{instanceId}/backups',
    description=""" Display all backups for an accessible Managed MySQL Database.

The Database must not be provisioning to perform this command.

Database `auto` type backups are created every 24 hours at 0:00 UTC. Each `auto` backup is retained for 7 days.

Database `snapshot` type backups are created by accessing the **Managed MySQL Database Backup Snapshot Create** ([POST /databases/mysql/instances/{instanceId}/backups](/docs/api/databases/#managed-mysql-database-backup-snapshot-create)) command.
 """,
    tags=[
        'managed_database_operations',
        'mysql_database_operations',
        'backup_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_my_s_q_l_instance_backups(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    instance_id: int = Path(..., alias='instanceId'),
):
    """
    Managed MySQL Database Backups List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/mysql/instances/{instanceId}/backups',
    description=""" Creates a snapshot backup of a Managed MySQL Database.

Requires `read_write` access to the Database.

Up to 3 snapshot backups for each Database can be stored at a time. If 3 snapshots have been created for a Database, one must be deleted before another can be made.

Backups generated by this command have the type `snapshot`. Snapshot backups may take several minutes to complete, after which they will be accessible to view or restore.

The Database must have an `active` status to perform this command. If another backup is in progress, it must complete before a new backup can be initiated.
 """,
    tags=[
        'managed_database_operations',
        'mysql_database_operations',
        'backup_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_my_s_q_l_instance_backup(
    instance_id: int = Path(..., alias='instanceId'),
    body: DatabaseBackupSnapshot = None,
):
    """
    Managed MySQL Database Backup Snapshot Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/databases/mysql/instances/{instanceId}/backups/{backupId}',
    description=""" Delete a single backup for an accessible Managed MySQL Database.

Requires `read_write` access to the Database.

The Database must not be provisioning to perform this command.
 """,
    tags=[
        'mysql_database_operations',
        'managed_database_operations',
        'backup_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_database_my_s_q_l_instance_backup(
    instance_id: int = Path(..., alias='instanceId'),
    backup_id: int = Path(..., alias='backupId'),
):
    """
    Managed MySQL Database Backup Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mysql/instances/{instanceId}/backups/{backupId}',
    description=""" Display information for a single backup for an accessible Managed MySQL Database.

The Database must not be provisioning to perform this command.
 """,
    tags=['managed_database_operations', 'mysql_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_my_s_q_l_instance_backup(
    instance_id: int = Path(..., alias='instanceId'),
    backup_id: int = Path(..., alias='backupId'),
):
    """
    Managed MySQL Database Backup View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/mysql/instances/{instanceId}/backups/{backupId}/restore',
    description=""" Restore a backup to a Managed MySQL Database on your Account.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this command.

**Note**: Restoring from a backup will erase all existing data on the database instance and replace it with backup data.

**Note**: Currently, restoring a backup after resetting Managed Database credentials results in a failed cluster. Please contact Customer Support if this occurs.
 """,
    tags=[
        'mysql_database_operations',
        'managed_database_operations',
        'backup_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_my_s_q_l_instance_backup_restore(
    instance_id: int = Path(..., alias='instanceId'),
    backup_id: int = Path(..., alias='backupId'),
):
    """
    Managed MySQL Database Backup Restore
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mysql/instances/{instanceId}/credentials',
    description=""" Display the root username and password for an accessible Managed MySQL Database.

The Database must have an `active` status to perform this command.
 """,
    tags=['managed_database_operations', 'mysql_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_my_s_q_l_instance_credentials(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed MySQL Database Credentials View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/mysql/instances/{instanceId}/credentials/reset',
    description=""" Reset the root password for a Managed MySQL Database.

Requires `read_write` access to the Database.

A new root password is randomly generated and accessible with the **Managed MySQL Database Credentials View** ([GET /databases/mysql/instances/{instanceId}/credentials](/docs/api/databases/#managed-mysql-database-credentials-view)) command.

Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.

**Note**: Note that it may take several seconds for credentials to reset.
 """,
    tags=['mysql_database_operations', 'managed_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_my_s_q_l_instance_credentials_reset(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed MySQL Database Credentials Reset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/mysql/instances/{instanceId}/patch',
    description=""" Apply security patches and updates to the underlying operating system of the Managed MySQL Database. This function runs during regular maintenance windows, which are configurable with the **Managed MySQL Database Update** ([PUT /databases/mysql/instances/{instanceId}](/docs/api/databases/#managed-mysql-database-update)) command.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this command.

**Note**

* If your database cluster is configured with a single node, you will experience downtime during this maintenance. Consider upgrading to a high availability plan to avoid any downtime due to maintenance.

* **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then [migrate your databases](/docs/products/databases/managed-databases/guides/migrate-mysql/) from the original Managed Database cluster to the new one.
 """,
    tags=['mysql_database_operations', 'managed_database_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_my_s_q_l_instance_patch(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed MySQL Database Patch
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/mysql/instances/{instanceId}/ssl',
    description=""" Display the SSL CA certificate for an accessible Managed MySQL Database.

The Database must have an `active` status to perform this command.
 """,
    tags=[
        'managed_database_operations',
        'mysql_database_operations',
        'database_type_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_my_s_q_l_instance_s_s_l(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed MySQL Database SSL Certificate View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/postgresql/instances',
    description=""" Display all accessible Managed PostgreSQL Databases.
 """,
    tags=[
        'managed_database_operations',
        'postgres_database_operations',
        'postgresql_database_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_postgre_s_q_l_instances(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Managed PostgreSQL Databases List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/postgresql/instances',
    description=""" Provision a Managed PostgreSQL Database.

Restricted Users must have the `add_databases` grant to use this command.

New instances can take approximately 15 to 30 minutes to provision.

The `allow_list` is used to control access to the Managed Database.

* IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.

* If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.

* Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.

All Managed Databases include automatic, daily backups. Up to seven backups are automatically stored for each Managed Database, providing restore points for each day of the past week.

All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed PostgreSQL Database during configurable maintenance windows.

* If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.

* **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.

* To modify update the maintenance window for a Database, use the **Managed PostgreSQL Database Update** ([PUT /databases/postgresql/instances/{instanceId}](/docs/api/databases/#managed-postgresql-database-update)) command.
 """,
    tags=[
        'postgres_database_operations',
        'managed_database_operations',
        'postgresql_database_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_postgre_s_q_l_instances(body: DatabasePostgreSQLRequest):
    """
    Managed PostgreSQL Database Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/databases/postgresql/instances/{instanceId}',
    description=""" Remove a Managed PostgreSQL Database from your Account.

Requires `read_write` access to the Database.

The Database must have an `active`, `failed`, or `degraded` status to perform this command.

Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.
 """,
    tags=['postgres_database_operations', 'postgresql_database_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_databases_postgre_s_q_l_instance(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed PostgreSQL Database Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/postgresql/instances/{instanceId}',
    description=""" Display information for a single, accessible Managed PostgreSQL Database.
 """,
    tags=[
        'postgres_database_operations',
        'managed_database_operations',
        'postgresql_database_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_postgre_s_q_l_instance(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed PostgreSQL Database View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/databases/postgresql/instances/{instanceId}',
    description=""" Update a Managed PostgreSQL Database.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this command.

Updating addresses in the `allow_list` overwrites any existing addresses.

* IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.

* If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.

* Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.

* **Note**: Updates to the `allow_list` may take a short period of time to complete, making this command inappropriate for rapid successive updates to this property.

All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed PostgreSQL Database. The maintenance window for these updates is configured with the Managed Database's `updates` property.

* If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.

* **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.
 """,
    tags=[
        'postgres_database_operations',
        'managed_database_operations',
        'postgresql_database_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def put_databases_postgre_s_q_l_instance(
    instance_id: int = Path(..., alias='instanceId'),
    body: DatabasesPostgresqlInstancesInstanceIdPutRequest = ...,
):
    """
    Managed PostgreSQL Database Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/postgresql/instances/{instanceId}/backups',
    description=""" Display all backups for an accessible Managed PostgreSQL Database.

The Database must not be provisioning to perform this command.

Database `auto` type backups are created every 24 hours at 0:00 UTC. Each `auto` backup is retained for 7 days.

Database `snapshot` type backups are created by accessing the **Managed PostgreSQL Database Backup Snapshot Create** ([POST /databases/postgresql/instances/{instanceId}/backups](/docs/api/databases/#managed-postgresql-database-backup-snapshot-create)) command.
 """,
    tags=[
        'postgresql_backup_management',
        'managed_database_operations',
        'postgres_database_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_postgre_s_q_l_instance_backups(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    instance_id: int = Path(..., alias='instanceId'),
):
    """
    Managed PostgreSQL Database Backups List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/postgresql/instances/{instanceId}/backups',
    description=""" Creates a snapshot backup of a Managed PostgreSQL Database.

Requires `read_write` access to the Database.

Up to 3 snapshot backups for each Database can be stored at a time. If 3 snapshots have been created for a Database, one must be deleted before another can be made.

Backups generated by this command have the type `snapshot`. Snapshot backups may take several minutes to complete, after which they will be accessible to view or restore.

The Database must have an `active` status to perform this command. If another backup is in progress, it must complete before a new backup can be initiated.
 """,
    tags=[
        'postgresql_backup_management',
        'managed_database_operations',
        'postgres_database_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_postgre_s_q_l_instance_backup(
    instance_id: int = Path(..., alias='instanceId'),
    body: DatabaseBackupSnapshot = None,
):
    """
    Managed PostgreSQL Database Backup Snapshot Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/databases/postgresql/instances/{instanceId}/backups/{backupId}',
    description=""" Delete a single backup for an accessible Managed PostgreSQL Database.

Requires `read_write` access to the Database.

The Database must not be provisioning to perform this command.
 """,
    tags=[
        'postgresql_backup_management',
        'managed_database_operations',
        'postgres_database_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_database_postgre_s_q_l_instance_backup(
    instance_id: int = Path(..., alias='instanceId'),
    backup_id: int = Path(..., alias='backupId'),
):
    """
    Managed PostgreSQL Database Backup Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/postgresql/instances/{instanceId}/backups/{backupId}',
    description=""" Display information for a single backup for an accessible Managed PostgreSQL Database.

The Database must not be provisioning to perform this command.
 """,
    tags=[
        'postgresql_backup_management',
        'managed_database_operations',
        'postgres_database_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_postgre_s_q_l_instance_backup(
    instance_id: int = Path(..., alias='instanceId'),
    backup_id: int = Path(..., alias='backupId'),
):
    """
    Managed PostgreSQL Database Backup View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/postgresql/instances/{instanceId}/backups/{backupId}/restore',
    description=""" Restore a backup to a Managed PostgreSQL Database on your Account.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this command.

**Note**: Restoring from a backup will erase all existing data on the database instance and replace it with backup data.

**Note**: Currently, restoring a backup after resetting Managed Database credentials results in a failed cluster. Please contact Customer Support if this occurs.
 """,
    tags=[
        'postgresql_backup_management',
        'postgres_database_operations',
        'managed_database_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_postgre_s_q_l_instance_backup_restore(
    instance_id: int = Path(..., alias='instanceId'),
    backup_id: int = Path(..., alias='backupId'),
):
    """
    Managed PostgreSQL Database Backup Restore
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/postgresql/instances/{instanceId}/credentials',
    description=""" Display the root username and password for an accessible Managed PostgreSQL Database.

The Database must have an `active` status to perform this command.
 """,
    tags=[
        'postgresql_credentials_management',
        'postgres_database_operations',
        'managed_database_operations',
        'postgresql_database_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_postgre_s_q_l_instance_credentials(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed PostgreSQL Database Credentials View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/postgresql/instances/{instanceId}/credentials/reset',
    description=""" Reset the root password for a Managed PostgreSQL Database.

Requires `read_write` access to the Database.

A new root password is randomly generated and accessible with the **Managed PostgreSQL Database Credentials View** ([GET /databases/postgresql/instances/{instanceId}/credentials](/docs/api/databases/#managed-postgresql-database-credentials-view)) command.

Only unrestricted Users can access this command, and have access regardless of the acting token's OAuth scopes.

**Note**: Note that it may take several seconds for credentials to reset.
 """,
    tags=[
        'postgresql_credentials_management',
        'managed_database_operations',
        'postgres_database_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_postgre_s_q_l_instance_credentials_reset(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed PostgreSQL Database Credentials Reset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/databases/postgresql/instances/{instanceId}/patch',
    description=""" Apply security patches and updates to the underlying operating system of the Managed PostgreSQL Database. This function runs during regular maintenance windows, which are configurable with the **Managed PostgreSQL Database Update** ([PUT /databases/postgresql/instances/{instanceId}](/docs/api/databases/#managed-postgresql-database-update)) command.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this command.

**Note**

* If your database cluster is configured with a single node, you will experience downtime during this maintenance. Consider upgrading to a high availability plan to avoid any downtime due to maintenance.

* **The database software is not updated automatically.** To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.
 """,
    tags=['postgres_database_operations', 'postgresql_database_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_databases_postgre_s_q_l_instance_patch(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed PostgreSQL Database Patch
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/postgresql/instances/{instanceId}/ssl',
    description=""" Display the SSL CA certificate for an accessible Managed PostgreSQL Database.

The Database must have an `active` status to perform this command.
 """,
    tags=['postgres_database_operations', 'postgresql_database_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_databases_postgre_s_q_l_instance_s_s_l(
    instance_id: int = Path(..., alias='instanceId')
):
    """
    Managed PostgreSQL Database SSL Certificate View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/types',
    description=""" Display all Managed Database node types. The type and number of nodes determine the resources and price of a Managed Database instance.

Each Managed Database can have one node type. In the case of a high availabilty Database, all nodes are provisioned according to the chosen type.
 """,
    tags=['managed_database_operations', 'database_type_management'],
)
def get_databases_types(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Managed Database Types List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/databases/types/{typeId}',
    description=""" Display the details of a single Managed Database type. The type and number of nodes determine the resources and price of a Managed Database instance.
 """,
    tags=['managed_database_operations', 'database_type_management'],
)
def get_databases_type(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    type_id: str = Path(..., alias='typeId'),
):
    """
    Managed Database Type View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/domains',
    description=""" This is a collection of Domains that you have registered in Linode's DNS Manager.  Linode is not a registrar, and in order for these to work you must own the domains and point your registrar at Linode's nameservers.
 """,
    tags=['domain_management', 'domain_record_management', 'domain_zone_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_domains(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Domains List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/domains',
    description=""" Adds a new Domain to Linode's DNS Manager. Linode is not a registrar, and you must own the domain before adding it here. Be sure to point your registrar to Linode's nameservers so that the records hosted here are used.
 """,
    tags=['domain_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_domain(body: DomainsPostRequest):
    """
    Domain Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/domains/import',
    description=""" Imports a domain zone from a remote nameserver.
Your nameserver must allow zone transfers (AXFR) from the following IPs:

  - 96.126.114.97
  - 96.126.114.98
  - 2600:3c00::5e
  - 2600:3c00::5f
 """,
    tags=['domain_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def import_domain(body: DomainsImportPostRequest = None):
    """
    Domain Import
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/domains/{domainId}',
    description=""" Deletes a Domain from Linode's DNS Manager. The Domain will be removed from Linode's nameservers shortly after this operation completes. This also deletes all associated Domain Records.
 """,
    tags=['domain_management', 'domain_record_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_domain(domain_id: int = Path(..., alias='domainId')):
    """
    Domain Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/domains/{domainId}',
    description=""" This is a single Domain that you have registered in Linode's DNS Manager. Linode is not a registrar, and in order for this Domain record to work you must own the domain and point your registrar at Linode's nameservers.
 """,
    tags=['domain_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_domain(domain_id: int = Path(..., alias='domainId')):
    """
    Domain View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/domains/{domainId}',
    description=""" Update information about a Domain in Linode's DNS Manager.
 """,
    tags=['domain_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_domain(domain_id: int = Path(..., alias='domainId'), body: Domain = ...):
    """
    Domain Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/domains/{domainId}/clone',
    description=""" Clones a Domain and all associated DNS records from a Domain that is registered in Linode's DNS manager.
 """,
    tags=['domain_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def clone_domain(
    domain_id: str = Path(..., alias='domainId'),
    body: DomainsDomainIdClonePostRequest = ...,
):
    """
    Domain Clone
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/domains/{domainId}/records',
    description=""" Returns a paginated list of Records configured on a Domain in Linode's
DNS Manager.
 """,
    tags=['domain_management', 'domain_record_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_domain_records(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    domain_id: int = Path(..., alias='domainId'),
):
    """
    Domain Records List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/domains/{domainId}/records',
    description=""" Adds a new Domain Record to the zonefile this Domain represents.

Each domain can have up to 12,000 active records.
 """,
    tags=['domain_management', 'domain_record_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_domain_record(
    domain_id: int = Path(..., alias='domainId'),
    body: DomainsDomainIdRecordsPostRequest = ...,
):
    """
    Domain Record Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/domains/{domainId}/records/{recordId}',
    description=""" Deletes a Record on this Domain.
 """,
    tags=['domain_record_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_domain_record(
    domain_id: int = Path(..., alias='domainId'),
    record_id: int = Path(..., alias='recordId'),
):
    """
    Domain Record Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/domains/{domainId}/records/{recordId}',
    description=""" View a single Record on this Domain.
 """,
    tags=['domain_management', 'domain_record_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_domain_record(
    domain_id: int = Path(..., alias='domainId'),
    record_id: int = Path(..., alias='recordId'),
):
    """
    Domain Record View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/domains/{domainId}/records/{recordId}',
    description=""" Updates a single Record on this Domain.
 """,
    tags=['domain_management', 'domain_record_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_domain_record(
    domain_id: int = Path(..., alias='domainId'),
    record_id: int = Path(..., alias='recordId'),
    body: DomainsDomainIdRecordsRecordIdPutRequest = ...,
):
    """
    Domain Record Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/domains/{domainId}/zone-file',
    description=""" Returns the zone file for the last rendered zone for the specified domain.
 """,
    tags=['domain_management', 'domain_zone_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_domain_zone(domain_id: str = Path(..., alias='domainId')):
    """
    Domain Zone File View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images',
    description=""" Returns a paginated list of Images.

* **Public** Images have IDs that begin with "linode/". These distribution images are generally available to
all users.

* **Private** Images have IDs that begin with "private/". These Images are Account-specific and only
accessible to Users with appropriate [Grants](/docs/api/account/#users-grants-view).

* To view only public Images, call this endpoint with or without authentication. To view private Images as well, call this endpoint with authentication.
 """,
    tags=['image_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_images(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Images List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/images',
    description=""" Captures a private gold-master Image from a Linode Disk.
 """,
    tags=['image_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_image(body: ImagesPostRequest = None):
    """
    Image Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/images/upload',
    description=""" Initiates an Image upload.

This endpoint creates a new private Image object and returns it along
with the URL to which image data can be uploaded.

- Image data must be uploaded within 24 hours of creation or the
upload will be cancelled and the image deleted.

- Image uploads should be made as an HTTP PUT request to the URL returned in the `upload_to`
response parameter, with a `Content-type: application/octet-stream` header included in the
request. For example:

      curl -v \
        -H "Content-Type: application/octet-stream" \
        --upload-file example.img.gz \
        $UPLOAD_URL \
        --progress-bar \
        --output /dev/null

- Uploaded image data should be compressed in gzip (`.gz`) format. The uncompressed disk should be in raw
disk image (`.img`) format. A maximum compressed file size of 5GB is supported for upload at this time.

**Note:** To initiate and complete an Image upload in a single step, see our guide on how to [Upload an Image](/docs/products/tools/images/guides/upload-an-image/) using Cloud Manager or the Linode CLI `image-upload` plugin.
 """,
    tags=['image_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_images_upload(body: ImagesUploadPostRequest = None):
    """
    Image Upload
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/images/{imageId}',
    description=""" Deletes a private Image you have permission to `read_write`.


**Deleting an Image is a destructive action and cannot be undone.**
 """,
    tags=['image_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_image(image_id: str = Path(..., alias='imageId')):
    """
    Image Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{imageId}',
    description=""" Get information about a single Image.

* **Public** Images have IDs that begin with "linode/". These distribution images are generally available to
all users.

* **Private** Images have IDs that begin with "private/". These Images are Account-specific and only
accessible to Users with appropriate [Grants](/docs/api/account/#users-grants-view).

* To view a public Image, call this endpoint with or without authentication. To view a private Image, call this endpoint with authentication.
 """,
    tags=['image_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_image(image_id: str = Path(..., alias='imageId')):
    """
    Image View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/images/{imageId}',
    description=""" Updates a private Image that you have permission to `read_write`.
 """,
    tags=['image_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_image(image_id: str = Path(..., alias='imageId'), body: Image = ...):
    """
    Image Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances',
    description=""" Returns a paginated list of Linodes you have permission to view.
 """,
    tags=['linode_management', 'linode_instance_management', 'linode_statistics'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_instances(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Linodes List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances',
    description=""" Creates a Linode Instance on your Account. In order for this
request to complete successfully, your User must have the `add_linodes` grant. Creating a
new Linode will incur a charge on your Account.

Linodes can be created using one of the available Types. See
Types List ([GET /linode/types](/docs/api/linode-types/#types-list)) to get more
information about each Type's specs and cost.

Linodes can be created in any one of our available Regions, which are accessible from the
Regions List ([GET /regions](/docs/api/regions/#regions-list)) endpoint.

In an effort to fight spam, Linode restricts outbound connections on ports 25, 465, and 587
on all Linodes for new accounts created after November 5th, 2019. For more information,
see [Sending Email on Linode](/docs/guides/running-a-mail-server/#sending-email-on-linode).

Linodes can be created in a number of ways:

* Using a Linode Public Image distribution or a Private Image you created based on another Linode.
  * Access the Images List ([GET /images](/docs/api/images/#images-list)) endpoint with authentication to view
    all available Images.
  * The Linode will be `running` after it completes `provisioning`.
  * A default config with two Disks, one being a 512 swap disk, is created.
    * `swap_size` can be used to customize the swap disk size.
  * Requires a `root_pass` be supplied to use for the root User's Account.
  * It is recommended to supply SSH keys for the root User using the `authorized_keys` field.
  * You may also supply a list of usernames via the `authorized_users` field.
    * These users must have an SSH Key associated with your Profile first. See SSH Key Add ([POST /profile/sshkeys](/docs/api/profile/#ssh-key-add)) for more information.

* Using a StackScript.
  * See StackScripts List ([GET /linode/stackscripts](/docs/api/stackscripts/#stackscripts-list)) for
    a list of available StackScripts.
  * The Linode will be `running` after it completes `provisioning`.
  * Requires a compatible Image to be supplied.
    * See StackScript View ([GET /linode/stackscript/{stackscriptId}](/docs/api/stackscripts/#stackscript-view)) for compatible Images.
  * Requires a `root_pass` be supplied to use for the root User's Account.
  * It is recommended to supply SSH keys for the root User using the `authorized_keys` field.
  * You may also supply a list of usernames via the `authorized_users` field.
    * These users must have an SSH Key associated with your Profile first. See SSH Key Add ([POST /profile/sshkeys](/docs/api/profile/#ssh-key-add)) for more information.

* Using one of your other Linode's backups.
  * You must create a Linode large enough to accommodate the Backup's size.
  * The Disks and Config will match that of the Linode that was backed up.
  * The `root_pass` will match that of the Linode that was backed up.

* Attached to a private VLAN.
  * Review the `interfaces` property of the [Request Body Schema](/docs/api/linode-instances/#linode-create__request-body-schema) for details.
  * For more information, see our guide on [Getting Started with VLANs](/docs/products/networking/vlans/get-started/).

* Create an empty Linode.
  * The Linode will remain `offline` and must be manually started.
    * See Linode Boot ([POST /linode/instances/{linodeId}/boot](/docs/api/linode-instances/#linode-boot)).
  * Disks and Configs must be created manually.
  * This is only recommended for advanced use cases.

**Important**: You must be an unrestricted User in order to add or modify
tags on Linodes.
 """,
    tags=['linode_management', 'linode_instance_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_linode_instance(body: LinodeInstancesPostRequest):
    """
    Linode Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/linode/instances/{linodeId}',
    description=""" Deletes a Linode you have permission to `read_write`.

**Deleting a Linode is a destructive action and cannot be undone.**

Additionally, deleting a Linode:

  * Gives up any IP addresses the Linode was assigned.
  * Deletes all Disks, Backups, Configs, etc.
  * Stops billing for the Linode and its associated services. You will be billed for time used
    within the billing period the Linode was active.

Linodes that are in the process of [cloning](/docs/api/linode-instances/#linode-clone) or [backup restoration](/docs/api/linode-instances/#backup-restore) cannot be deleted.
 """,
    tags=['linode_management', 'linode_instance_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_linode_instance(linode_id: int = Path(..., alias='linodeId')):
    """
    Linode Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}',
    description=""" Get a specific Linode by ID. """,
    tags=['linode_management', 'linode_instance_management', 'linode_statistics'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_instance(linode_id: int = Path(..., alias='linodeId')):
    """
    Linode View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/linode/instances/{linodeId}',
    description=""" Updates a Linode that you have permission to `read_write`.

**Important**: You must be an unrestricted User in order to add or modify tags on Linodes.
 """,
    tags=[
        'linode_management',
        'linode_instance_management',
        'managed_linode_settings_operations',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_linode_instance(
    linode_id: int = Path(..., alias='linodeId'), body: Linode = ...
):
    """
    Linode Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/backups',
    description=""" Returns information about this Linode's available backups.
 """,
    tags=['backup_operations', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_backups(linode_id: int = Path(..., alias='linodeId')):
    """
    Backups List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/backups',
    description=""" Creates a snapshot Backup of a Linode.

**Important:** If you already have a snapshot of this Linode, this is a destructive
action. The previous snapshot will be deleted.
 """,
    tags=['backup_operations', 'linode_management', 'linode_instance_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_snapshot(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdBackupsPostRequest = ...,
):
    """
    Snapshot Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/backups/cancel',
    description=""" Cancels the Backup service on the given Linode. Deletes all of this Linode's existing backups forever.
 """,
    tags=['linode_management', 'backup_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def cancel_backups(linode_id: int = Path(..., alias='linodeId')):
    """
    Backups Cancel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/backups/enable',
    description=""" Enables backups for the specified Linode.
 """,
    tags=['backup_operations', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def enable_backups(linode_id: int = Path(..., alias='linodeId')):
    """
    Backups Enable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/backups/{backupId}',
    description=""" Returns information about a Backup.
 """,
    tags=['backup_operations', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_backup(
    linode_id: int = Path(..., alias='linodeId'),
    backup_id: int = Path(..., alias='backupId'),
):
    """
    Backup View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/backups/{backupId}/restore',
    description=""" Restores a Linode's Backup to the specified Linode.
 """,
    tags=['backup_operations', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def restore_backup(
    linode_id: int = Path(..., alias='linodeId'),
    backup_id: int = Path(..., alias='backupId'),
    body: LinodeInstancesLinodeIdBackupsBackupIdRestorePostRequest = ...,
):
    """
    Backup Restore
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/boot',
    description=""" Boots a Linode you have permission to modify. If no parameters are given, a Config profile
will be chosen for this boot based on the following criteria:

* If there is only one Config profile for this Linode, it will be used.
* If there is more than one Config profile, the last booted config will be used.
* If there is more than one Config profile and none were the last to be booted (because the
  Linode was never booted or the last booted config was deleted) an error will be returned.
 """,
    tags=['linode_management', 'linode_instance_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def boot_linode_instance(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdBootPostRequest = None,
):
    """
    Linode Boot
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/clone',
    description=""" You can clone your Linode's existing Disks or Configuration profiles to
another Linode on your Account. In order for this request to complete
successfully, your User must have the `add_linodes` grant. Cloning to a
new Linode will incur a charge on your Account.

If cloning to an existing Linode, any actions currently running or
queued must be completed first before you can clone to it.

Up to five clone operations from any given source Linode can be run concurrently.
If more concurrent clones are attempted, an HTTP 400 error will be
returned by this endpoint.

Any [tags](/docs/api/tags/#tags-list) existing on the source Linode will be cloned to the target Linode.
 """,
    tags=['linode_management', 'linode_instance_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def clone_linode_instance(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdClonePostRequest = ...,
):
    """
    Linode Clone
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/configs',
    description=""" Lists Configuration profiles associated with a Linode.
 """,
    tags=['configuration_profiles'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_configs(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    linode_id: int = Path(..., alias='linodeId'),
):
    """
    Configuration Profiles List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/configs',
    description=""" Adds a new Configuration profile to a Linode.
 """,
    tags=['configuration_profiles', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_linode_config(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdConfigsPostRequest = ...,
):
    """
    Configuration Profile Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/linode/instances/{linodeId}/configs/{configId}',
    description=""" Deletes the specified Configuration profile from the specified Linode.
 """,
    tags=['configuration_profiles', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_linode_config(
    linode_id: int = Path(..., alias='linodeId'),
    config_id: int = Path(..., alias='configId'),
):
    """
    Configuration Profile Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/configs/{configId}',
    description=""" Returns information about a specific Configuration profile.
 """,
    tags=['configuration_profiles', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_config(
    linode_id: int = Path(..., alias='linodeId'),
    config_id: int = Path(..., alias='configId'),
):
    """
    Configuration Profile View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/linode/instances/{linodeId}/configs/{configId}',
    description=""" Updates a Configuration profile.
 """,
    tags=['configuration_profiles', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_linode_config(
    linode_id: int = Path(..., alias='linodeId'),
    config_id: int = Path(..., alias='configId'),
    body: LinodeConfig = ...,
):
    """
    Configuration Profile Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/disks',
    description=""" View Disk information for Disks associated with this Linode.
 """,
    tags=['disk_management', 'linode_management', 'volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_disks(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    linode_id: int = Path(..., alias='linodeId'),
):
    """
    Disks List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/disks',
    description=""" Adds a new Disk to a Linode.

* You can optionally create a Disk from an Image or an Empty Disk if no Image is provided with a request.

* When creating an Empty Disk, providing a `label` is required.

* If no `label` is provided, an `image` is required instead.

* When creating a Disk from an Image, `root_pass` is required.

* The default filesystem for new Disks is `ext4`. If creating a Disk from an Image, the filesystem
of the Image is used unless otherwise specified.

* When deploying a StackScript on a Disk:
  * See StackScripts List ([GET /linode/stackscripts](/docs/api/stackscripts/#stackscripts-list)) for
    a list of available StackScripts.
  * Requires a compatible Image to be supplied.
    * See StackScript View ([GET /linode/stackscript/{stackscriptId}](/docs/api/stackscripts/#stackscript-view)) for compatible Images.
  * It is recommended to supply SSH keys for the root User using the `authorized_keys` field.
  * You may also supply a list of usernames via the `authorized_users` field.
    * These users must have an SSH Key associated with their Profiles first. See SSH Key Add ([POST /profile/sshkeys](/docs/api/profile/#ssh-key-add)) for more information.
 """,
    tags=['linode_management', 'disk_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_linode_disk(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdDisksPostRequest = ...,
):
    """
    Disk Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/linode/instances/{linodeId}/disks/{diskId}',
    description=""" Deletes a Disk you have permission to `read_write`.

**Deleting a Disk is a destructive action and cannot be undone.**
 """,
    tags=['linode_management', 'disk_management', 'volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_disk(
    linode_id: int = Path(..., alias='linodeId'),
    disk_id: int = Path(..., alias='diskId'),
):
    """
    Disk Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/disks/{diskId}',
    description=""" View Disk information for a Disk associated with this Linode.
 """,
    tags=['disk_management', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_disk(
    linode_id: int = Path(..., alias='linodeId'),
    disk_id: int = Path(..., alias='diskId'),
):
    """
    Disk View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/linode/instances/{linodeId}/disks/{diskId}',
    description=""" Updates a Disk that you have permission to `read_write`.
 """,
    tags=['disk_management', 'linode_management', 'volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_disk(
    linode_id: int = Path(..., alias='linodeId'),
    disk_id: int = Path(..., alias='diskId'),
    body: Disk1 = ...,
):
    """
    Disk Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/disks/{diskId}/clone',
    description=""" Copies a disk, byte-for-byte, into a new Disk belonging to the same Linode. The Linode must have enough storage space available to accept a new Disk of the same size as this one or this operation will fail.
 """,
    tags=['disk_management', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def clone_linode_disk(
    linode_id: int = Path(..., alias='linodeId'),
    disk_id: int = Path(..., alias='diskId'),
):
    """
    Disk Clone
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/disks/{diskId}/password',
    description=""" Resets the password of a Disk you have permission to `read_write`.
 """,
    tags=['disk_management', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def reset_disk_password(
    linode_id: int = Path(..., alias='linodeId'),
    disk_id: int = Path(..., alias='diskId'),
    body: LinodeInstancesLinodeIdDisksDiskIdPasswordPostRequest = ...,
):
    """
    Disk Root Password Reset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/disks/{diskId}/resize',
    description=""" Resizes a Disk you have permission to `read_write`.

The Disk must not be in use. If the Disk is in use, the request will
succeed but the resize will ultimately fail. For a request to succeed,
the Linode must be shut down prior to resizing the Disk, or the Disk
must not be assigned to the Linode's active Configuration Profile.

If you are resizing the Disk to a smaller size, it cannot be made smaller
than what is required by the total size of the files current on the Disk.
 """,
    tags=['disk_management', 'volume_management', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def resize_disk(
    linode_id: int = Path(..., alias='linodeId'),
    disk_id: int = Path(..., alias='diskId'),
    body: LinodeInstancesLinodeIdDisksDiskIdResizePostRequest = ...,
):
    """
    Disk Resize
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/firewalls',
    description=""" View Firewall information for Firewalls associated with this Linode.
 """,
    tags=['firewall_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_firewalls(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    linode_id: int = Path(..., alias='linodeId'),
):
    """
    Firewalls List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/ips',
    description=""" Returns networking information for a single Linode.
 """,
    tags=['linode_ip_management', 'linode_management', 'networking_information'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_i_ps(linode_id: int = Path(..., alias='linodeId')):
    """
    Networking Information List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/ips',
    description=""" Allocates a public or private IPv4 address to a Linode. Public IP Addresses, after the one included with each Linode, incur an additional monthly charge. If you need an additional public IP Address you must request one - please [open a support ticket](/docs/api/support/#support-ticket-open). You may not add more than one private IPv4 address to a single Linode.
 """,
    tags=['ip_address_management', 'linode_ip_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_linode_i_p(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdIpsPostRequest = ...,
):
    """
    IPv4 Address Allocate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/linode/instances/{linodeId}/ips/{address}',
    description=""" Deletes a public or private IPv4 address associated with this Linode. This will fail if it is the Linode's last remaining public IPv4 address.
 """,
    tags=['linode_ip_management', 'ip_address_management', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_linode_i_p(linode_id: int = Path(..., alias='linodeId'), address: str = ...):
    """
    IPv4 Address Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/ips/{address}',
    description=""" View information about the specified IP address associated with the specified Linode.
 """,
    tags=['ip_address_management', 'linode_ip_management', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_i_p(linode_id: int = Path(..., alias='linodeId'), address: str = ...):
    """
    IP Address View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/linode/instances/{linodeId}/ips/{address}',
    description=""" Updates a the reverse DNS (RDNS) for a particular IP Address associated with this Linode.

Setting the RDNS to `null` for a public IPv4 address, resets it to the default "ip.linodeusercontent.com" RDNS value.
 """,
    tags=['ip_address_management', 'linode_ip_management', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_linode_i_p(
    linode_id: int = Path(..., alias='linodeId'),
    address: str = ...,
    body: LinodeInstancesLinodeIdIpsAddressPutRequest = None,
):
    """
    IP Address Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/migrate',
    description=""" Initiate a pending host migration that has been scheduled by Linode or initiate a cross data center (DC) migration.  A list of pending migrations, if any, can be accessed from [GET /account/notifications](/docs/api/account/#notifications-list). When the migration begins, your Linode will be shutdown if not already off. If the migration initiated the shutdown, it will reboot the Linode when completed.

To initiate a cross DC migration, you must pass a `region` parameter to the request body specifying the target data center region. You can view a list of all available regions and their feature capabilities from [GET /regions](/docs/api/regions/#regions-list). If your Linode has a DC migration already queued or you have initiated a previously scheduled migration, you will not be able to initiate a DC migration until it has completed.

**Note:** Next Generation Network (NGN) data centers do not support IPv6 `/116` pools or IP Failover. If you have these features enabled on your Linode and attempt to migrate to an NGN data center, the migration will not initiate. If a Linode cannot be migrated because of an incompatibility, you will be prompted to select a different data center or contact support.
 """,
    tags=['service_transfer_management', 'linode_instance_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def migrate_linode_instance(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdMigratePostRequest = None,
):
    """
    DC Migration/Pending Host Migration Initiate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/mutate',
    description=""" Linodes created with now-deprecated Types are entitled to a free upgrade to the next generation. A mutating Linode will be allocated any new resources the upgraded Type provides, and will be subsequently restarted if it was currently running.
If any actions are currently running or queued, those actions must be completed first before you can initiate a mutate.
 """,
    tags=['linode_management', 'linode_instance_management', 'configuration_profiles'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def mutate_linode_instance(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdMutatePostRequest = None,
):
    """
    Linode Upgrade
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/nodebalancers',
    description=""" Returns a list of NodeBalancers that are assigned to this Linode and readable by the requesting User.

Read permission to a NodeBalancer can be given to a User by accessing the User's Grants Update
([PUT /account/users/{username}/grants](/docs/api/account/#users-grants-update)) endpoint.
 """,
    tags=[
        'node_balancer_management',
        'linode_management',
        'node_balancer_configs_management',
        'node_balancer_nodes_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_node_balancers(linode_id: int = Path(..., alias='linodeId')):
    """
    Linode NodeBalancers View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/password',
    description=""" Resets the root password for this Linode.
* Your Linode must be [shut down](/docs/api/linode-instances/#linode-shut-down) for a password reset to complete.
* If your Linode has more than one disk (not counting its swap disk), use the [Reset Disk Root Password](/docs/api/linode-instances/#disk-root-password-reset) endpoint to update a specific disk's root password.
* A `password_reset` event is generated when a root password reset is successful.
 """,
    tags=['linode_management', 'linode_instance_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def reset_linode_password(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdPasswordPostRequest = None,
):
    """
    Linode Root Password Reset
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/reboot',
    description=""" Reboots a Linode you have permission to modify. If any actions are currently running or queued, those actions must be completed first before you can initiate a reboot.
 """,
    tags=['linode_instance_management', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def reboot_linode_instance(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdRebootPostRequest = None,
):
    """
    Linode Reboot
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/rebuild',
    description=""" Rebuilds a Linode you have the `read_write` permission to modify.
A rebuild will first shut down the Linode, delete all disks and configs on the Linode, and then deploy a new `image` to the Linode with the given attributes. Additionally:

  * Requires an `image` be supplied.
  * Requires a `root_pass` be supplied to use for the root User's Account.
  * It is recommended to supply SSH keys for the root User using the
    `authorized_keys` field.
 """,
    tags=['linode_management', 'linode_instance_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def rebuild_linode_instance(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdRebuildPostRequest = ...,
):
    """
    Linode Rebuild
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/rescue',
    description=""" Rescue Mode is a safe environment for performing many system recovery and disk management tasks. Rescue Mode is based on the Finnix recovery distribution, a self-contained and bootable Linux distribution. You can also use Rescue Mode for tasks other than disaster recovery, such as formatting disks to use different filesystems, copying data between disks, and downloading files from a disk via SSH and SFTP.
* Note that "sdh" is reserved and unavailable during rescue.
 """,
    tags=['linode_management', 'linode_instance_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def rescue_linode_instance(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdRescuePostRequest = None,
):
    """
    Linode Boot into Rescue Mode
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/resize',
    description=""" Resizes a Linode you have the `read_write` permission to a different Type. If any actions are currently running or queued, those actions must be completed first before you can initiate a resize. Additionally, the following criteria must be met in order to resize a Linode:

  * The Linode must not have a pending migration.
  * Your Account cannot have an outstanding balance.
  * The Linode must not have more disk allocation than the new Type allows.
    * In that situation, you must first delete or resize the disk to be smaller.
 """,
    tags=[
        'linode_management',
        'disk_management',
        'volume_management',
        'linode_instance_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def resize_linode_instance(
    linode_id: int = Path(..., alias='linodeId'),
    body: LinodeInstancesLinodeIdResizePostRequest = ...,
):
    """
    Linode Resize
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/instances/{linodeId}/shutdown',
    description=""" Shuts down a Linode you have permission to modify. If any actions are currently running or queued, those actions must be completed first before you can initiate a shutdown.
 """,
    tags=['linode_management', 'linode_instance_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def shutdown_linode_instance(linode_id: int = Path(..., alias='linodeId')):
    """
    Linode Shut Down
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/stats',
    description=""" Returns CPU, IO, IPv4, and IPv6 statistics for your Linode for the past 24 hours.
 """,
    tags=['linode_statistics', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_stats(linode_id: int = Path(..., alias='linodeId')):
    """
    Linode Statistics View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/stats/{year}/{month}',
    description=""" Returns statistics for a specific month. The year/month values must be either a date in the past, or the current month. If the current month, statistics will be retrieved for the past 30 days.
 """,
    tags=['linode_statistics', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_stats_by_year_month(
    linode_id: int = Path(..., alias='linodeId'),
    year: int = ...,
    month: conint(ge=1, le=12) = ...,
):
    """
    Statistics View (year/month)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/transfer',
    description=""" Returns a Linode's network transfer pool statistics for the current month.
 """,
    tags=[
        'entity_transfer_operations',
        'service_transfer_management',
        'linode_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_transfer(linode_id: int = Path(..., alias='linodeId')):
    """
    Network Transfer View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/transfer/{year}/{month}',
    description=""" Returns a Linode's network transfer statistics for a specific month. The year/month values must be either a date in the past, or the current month.
 """,
    tags=['service_transfer_management', 'linode_management', 'linode_statistics'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_transfer_by_year_month(
    linode_id: int = Path(..., alias='linodeId'),
    year: conint(ge=2000, le=2037) = ...,
    month: conint(ge=1, le=12) = ...,
):
    """
    Network Transfer View (year/month)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/instances/{linodeId}/volumes',
    description=""" View Block Storage Volumes attached to this Linode.
 """,
    tags=['linode_volume_management', 'volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linode_volumes(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    linode_id: int = Path(..., alias='linodeId'),
):
    """
    Linode's Volumes List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/kernels',
    description=""" Lists available Kernels.
 """,
    tags=['linode_kernels'],
)
def get_kernels(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Kernels List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/kernels/{kernelId}',
    description=""" Returns information about a single Kernel.
 """,
    tags=['linode_kernels'],
)
def get_kernel(kernel_id: str = Path(..., alias='kernelId')):
    """
    Kernel View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/stackscripts',
    description=""" If the request is not authenticated, only public StackScripts are returned.

For more information on StackScripts, please read our [StackScripts documentation](/docs/products/tools/stackscripts/).
 """,
    tags=['linode_stack_scripts'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_stack_scripts(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    StackScripts List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/linode/stackscripts',
    description=""" Creates a StackScript in your Account.
 """,
    tags=['linode_stack_scripts'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_stack_script(body: LinodeStackscriptsPostRequest):
    """
    StackScript Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/linode/stackscripts/{stackscriptId}',
    description=""" Deletes a private StackScript you have permission to `read_write`. You cannot delete a public StackScript.
 """,
    tags=['linode_stack_scripts', 'service_transfer_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_stack_script(stackscript_id: str = Path(..., alias='stackscriptId')):
    """
    StackScript Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/stackscripts/{stackscriptId}',
    description=""" Returns all of the information about a specified StackScript, including the contents of the script.
 """,
    tags=['linode_stack_scripts'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_stack_script(stackscript_id: str = Path(..., alias='stackscriptId')):
    """
    StackScript View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/linode/stackscripts/{stackscriptId}',
    description=""" Updates a StackScript.

**Once a StackScript is made public, it cannot be made private.**
 """,
    tags=['linode_stack_scripts'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_stack_script(
    stackscript_id: str = Path(..., alias='stackscriptId'), body: StackScript = None
):
    """
    StackScript Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/types',
    description=""" Returns collection of Linode Types, including pricing and specifications for each Type. These are used when [creating](/docs/api/linode-instances/#linode-create) or [resizing](/docs/api/linode-instances/#linode-resize) Linodes.
 """,
    tags=['database_type_management'],
)
def get_linode_types():
    """
    Types List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/linode/types/{typeId}',
    description=""" Returns information about a specific Linode Type, including pricing and specifications. This is used when [creating](/docs/api/linode-instances/#linode-create) or [resizing](/docs/api/linode-instances/#linode-resize) Linodes.
 """,
    tags=['entity_transfer_operations'],
)
def get_linode_type(type_id: str = Path(..., alias='typeId')):
    """
    Type View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lke/clusters',
    description=""" Lists current Kubernetes clusters available on your account.
 """,
    tags=['linode_kubernetes_management', 'kubernetes_cluster_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_l_k_e_clusters():
    """
    Kubernetes Clusters List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lke/clusters',
    description=""" Creates a Kubernetes cluster. The Kubernetes cluster will be created
asynchronously. You can use the events system to determine when the
Kubernetes cluster is ready to use. Please note that it often takes 2-5 minutes before the
[Kubernetes API server endpoint](/docs/api/linode-kubernetes-engine-lke/#kubernetes-api-endpoints-list) and
the [Kubeconfig file](/docs/api/linode-kubernetes-engine-lke/#kubeconfig-view) for the new cluster
are ready.
 """,
    tags=['linode_kubernetes_management', 'kubernetes_cluster_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_l_k_e_cluster(body: LkeClustersPostRequest = None):
    """
    Kubernetes Cluster Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/lke/clusters/{clusterId}',
    description=""" Deletes a Cluster you have permission to `read_write`.

**Deleting a Cluster is a destructive action and cannot be undone.**

Deleting a Cluster:
  - Deletes all Linodes in all pools within this Kubernetes cluster
  - Deletes all supporting Kubernetes services for this Kubernetes
    cluster (API server, etcd, etc)
  - Deletes all NodeBalancers created by this Kubernetes cluster
  - Does not delete any of the volumes created by this Kubernetes
    cluster
 """,
    tags=['linode_kubernetes_management', 'kubernetes_cluster_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_l_k_e_cluster(cluster_id: int = Path(..., alias='clusterId')):
    """
    Kubernetes Cluster Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lke/clusters/{clusterId}',
    description=""" Get a specific Cluster by ID.
 """,
    tags=['linode_kubernetes_management', 'kubernetes_cluster_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_l_k_e_cluster(cluster_id: int = Path(..., alias='clusterId')):
    """
    Kubernetes Cluster View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/lke/clusters/{clusterId}',
    description=""" Updates a Kubernetes cluster.
 """,
    tags=['linode_kubernetes_management', 'kubernetes_cluster_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def put_l_k_e_cluster(
    cluster_id: int = Path(..., alias='clusterId'),
    body: LkeClustersClusterIdPutRequest = None,
):
    """
    Kubernetes Cluster Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lke/clusters/{clusterId}/api-endpoints',
    description=""" List the Kubernetes API server endpoints for this cluster. Please note that it often takes 2-5 minutes before the endpoint is ready after first [creating a new cluster](/docs/api/linode-kubernetes-engine-lke/#kubernetes-cluster-create).
 """,
    tags=['kubernetes_cluster_management', 'linode_kubernetes_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_l_k_e_cluster_a_p_i_endpoints(cluster_id: int = Path(..., alias='clusterId')):
    """
    Kubernetes API Endpoints List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lke/clusters/{clusterId}/dashboard',
    description=""" Get a [Kubernetes Dashboard](https://github.com/kubernetes/dashboard) access URL for this Cluster, which enables performance of administrative tasks through a web interface.

Dashboards are installed for Clusters by default.

To access the Cluster Dashboard login prompt, enter the URL in a web browser. Select either **Token** or **Kubeconfig** authentication, then select **Sign in**.

For additional guidance on using the Cluster Dashboard, see the [Navigating the Cluster Dashboard](/docs/guides/using-the-kubernetes-dashboard-on-lke/#navigating-the-cluster-dashboard) section of our guide on [Using the Kubernetes Dashboard on LKE](/docs/guides/using-the-kubernetes-dashboard-on-lke/).
 """,
    tags=['kubernetes_cluster_management', 'linode_kubernetes_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_l_k_e_cluster_dashboard(cluster_id: int = Path(..., alias='clusterId')):
    """
    Kubernetes Cluster Dashboard URL View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/lke/clusters/{clusterId}/kubeconfig',
    description=""" Delete and regenerate the Kubeconfig file for a Cluster.
 """,
    tags=['kubernetes_cluster_management', 'linode_kubernetes_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_l_k_e_cluster_kubeconfig(cluster_id: int = Path(..., alias='clusterId')):
    """
    Kubeconfig Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lke/clusters/{clusterId}/kubeconfig',
    description=""" Get the Kubeconfig file for a Cluster. Please note that it often takes 2-5 minutes before
the Kubeconfig file is ready after first [creating a new cluster](/docs/api/linode-kubernetes-engine-lke/#kubernetes-cluster-create).
 """,
    tags=['kubernetes_cluster_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_l_k_e_cluster_kubeconfig(cluster_id: int = Path(..., alias='clusterId')):
    """
    Kubeconfig View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/lke/clusters/{clusterId}/nodes/{nodeId}',
    description=""" Deletes a specific Node from a Node Pool.

**Deleting a Node is a destructive action and cannot be undone.**

Deleting a Node will reduce the size of the Node Pool it belongs to.
 """,
    tags=['kubernetes_cluster_management', 'node_pool_management', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_l_k_e_cluster_node(
    cluster_id: int = Path(..., alias='clusterId'),
    node_id: str = Path(..., alias='nodeId'),
):
    """
    Node Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lke/clusters/{clusterId}/nodes/{nodeId}',
    description=""" Returns the values for a specified node object.
 """,
    tags=['kubernetes_cluster_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_l_k_e_cluster_node(
    cluster_id: int = Path(..., alias='clusterId'),
    node_id: str = Path(..., alias='nodeId'),
):
    """
    Node View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lke/clusters/{clusterId}/nodes/{nodeId}/recycle',
    description=""" Recycles an individual Node in the designated Kubernetes Cluster. The Node will be deleted
and replaced with a new Linode, which may take a few minutes. Replacement Nodes are
installed with the latest available patch for the Cluster's Kubernetes Version.

**Any local storage on deleted Linodes (such as "hostPath" and "emptyDir" volumes, or "local" PersistentVolumes) will be erased.**
 """,
    tags=['linode_management', 'kubernetes_cluster_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_l_k_e_cluster_node_recycle(
    cluster_id: int = Path(..., alias='clusterId'),
    node_id: str = Path(..., alias='nodeId'),
):
    """
    Node Recycle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lke/clusters/{clusterId}/pools',
    description=""" Returns all active Node Pools on a Kubernetes cluster.
 """,
    tags=['kubernetes_cluster_management', 'node_pool_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_l_k_e_cluster_pools(cluster_id: int = Path(..., alias='clusterId')):
    """
    Node Pools List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lke/clusters/{clusterId}/pools',
    description=""" Creates a new Node Pool for the designated Kubernetes cluster.
 """,
    tags=['kubernetes_cluster_management', 'node_pool_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_l_k_e_cluster_pools(
    cluster_id: int = Path(..., alias='clusterId'),
    body: LkeClustersClusterIdPoolsPostRequest = ...,
):
    """
    Node Pool Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/lke/clusters/{clusterId}/pools/{poolId}',
    description=""" Delete a specific Node Pool from a Kubernetes cluster.

**Deleting a Node Pool is a destructive action and cannot be undone.**

Deleting a Node Pool will delete all Linodes within that Pool.
 """,
    tags=['kubernetes_cluster_management', 'node_pool_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_l_k_e_node_pool(
    cluster_id: int = Path(..., alias='clusterId'),
    pool_id: int = Path(..., alias='poolId'),
):
    """
    Node Pool Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lke/clusters/{clusterId}/pools/{poolId}',
    description=""" Get a specific Node Pool by ID.
 """,
    tags=['kubernetes_cluster_management', 'node_pool_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_l_k_e_node_pool(
    cluster_id: int = Path(..., alias='clusterId'),
    pool_id: int = Path(..., alias='poolId'),
):
    """
    Node Pool View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/lke/clusters/{clusterId}/pools/{poolId}',
    description=""" Updates a Node Pool's count and autoscaler configuration.

Linodes will be created or deleted to match changes to the Node Pool's count.

**Any local storage on deleted Linodes (such as "hostPath" and "emptyDir" volumes, or "local" PersistentVolumes) will be erased.**
 """,
    tags=['kubernetes_cluster_management', 'node_pool_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def put_l_k_e_node_pool(
    cluster_id: int = Path(..., alias='clusterId'),
    pool_id: int = Path(..., alias='poolId'),
    body: LkeClustersClusterIdPoolsPoolIdPutRequest = None,
):
    """
    Node Pool Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lke/clusters/{clusterId}/pools/{poolId}/recycle',
    description=""" Recycles a Node Pool for the designated Kubernetes Cluster. All Linodes within the Node Pool will be deleted
and replaced with new Linodes on a rolling basis, which may take several minutes. Replacement Nodes are
installed with the latest available patch for the Cluster's Kubernetes Version.

**Any local storage on deleted Linodes (such as "hostPath" and "emptyDir" volumes, or "local" PersistentVolumes) will be erased.**
 """,
    tags=['kubernetes_cluster_management', 'node_pool_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_l_k_e_cluster_pool_recycle(
    cluster_id: int = Path(..., alias='clusterId'),
    pool_id: int = Path(..., alias='poolId'),
):
    """
    Node Pool Recycle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lke/clusters/{clusterId}/recycle',
    description=""" Recycles all nodes in all pools of a designated Kubernetes Cluster. All Linodes within the Cluster will be deleted
and replaced with new Linodes on a rolling basis, which may take several minutes. Replacement Nodes are
installed with the latest available [patch version](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/release/versioning.md#kubernetes-release-versioning) for the Cluster's current Kubernetes minor release.

**Any local storage on deleted Linodes (such as "hostPath" and "emptyDir" volumes, or "local" PersistentVolumes) will be erased.**
 """,
    tags=['kubernetes_cluster_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_l_k_e_cluster_recycle(cluster_id: int = Path(..., alias='clusterId')):
    """
    Cluster Nodes Recycle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/lke/clusters/{clusterId}/regenerate',
    description=""" Regenerate the Kubeconfig file and/or the service account token for a Cluster.

This is a helper command that allows performing both the [Kubeconfig Delete](#kubeconfig-delete) and the [Service Token Delete](#service-token-delete) actions with a single request.

When using this command, at least one of `kubeconfig` or `servicetoken` is required.

**Note**: When regenerating a service account token, the Cluster's control plane components and Linode CSI drivers are also restarted and configured with the new token. High Availability Clusters should not experience any disruption, while standard Clusters may experience brief control plane downtime while components are restarted.
 """,
    tags=['kubernetes_cluster_management', 'linode_kubernetes_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_l_k_e_cluster_regenerate(
    cluster_id: int = Path(..., alias='clusterId'),
    body: LkeClustersClusterIdRegeneratePostRequest = None,
):
    """
    Kubernetes Cluster Regenerate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/lke/clusters/{clusterId}/servicetoken',
    description=""" Delete and regenerate the service account token for a Cluster.

**Note**: When regenerating a service account token, the Cluster's control plane components and Linode CSI drivers are also restarted and configured with the new token. High Availability Clusters should not experience any disruption, while standard Clusters may experience brief control plane downtime while components are restarted.
 """,
    tags=['managed_service_management', 'service_transfer_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_l_k_e_c_service_token_delete(cluster_id: int = Path(..., alias='clusterId')):
    """
    Service Token Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lke/versions',
    description=""" List the Kubernetes versions available for deployment to a Kubernetes cluster.
 """,
    tags=['kubernetes_cluster_management', 'linode_kubernetes_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_l_k_e_versions():
    """
    Kubernetes Versions List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/lke/versions/{version}',
    description=""" View a Kubernetes version available for deployment to a Kubernetes cluster.
 """,
    tags=['kubernetes_cluster_management', 'linode_kubernetes_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_l_k_e_version(version: str):
    """
    Kubernetes Version View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/longview/clients',
    description=""" Returns a paginated list of Longview Clients you have access to. Longview Client is used to monitor stats on your Linode with the help of the Longview Client application.
 """,
    tags=['longview_client_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_longview_clients(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Longview Clients List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/longview/clients',
    description=""" Creates a Longview Client.  This Client will not begin monitoring the status of your server until you configure the Longview Client application on your Linode using the returning `install_code` and `api_key`.
 """,
    tags=['longview_client_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_longview_client(body: LongviewClient):
    """
    Longview Client Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/longview/clients/{clientId}',
    description=""" Deletes a Longview Client from your Account.

**All information stored for this client will be lost.**

This _does not_ uninstall the Longview Client application for your Linode - you must do that manually.
 """,
    tags=['longview_client_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_longview_client(client_id: int = Path(..., alias='clientId')):
    """
    Longview Client Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/longview/clients/{clientId}',
    description=""" Returns a single Longview Client you can access.
 """,
    tags=['longview_client_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_longview_client(client_id: int = Path(..., alias='clientId')):
    """
    Longview Client View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/longview/clients/{clientId}',
    description=""" Updates a Longview Client.  This cannot update how it monitors your server; use the Longview Client application on your Linode for monitoring configuration.
 """,
    tags=['longview_client_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_longview_client(
    client_id: int = Path(..., alias='clientId'), body: LongviewClient = ...
):
    """
    Longview Client Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/longview/plan',
    description=""" Get the details of your current Longview plan. This returns a `LongviewSubscription` object for your current Longview Pro plan, or an empty set `{}` if your current plan is Longview Free.

You must have at least one of the following `global` [User Grants](/docs/api/account/#users-grants-view) in order to access this endpoint:

  - `"account_access": read_write`
  - `"account_access": read_only`
  - `"longview_subscription": true`
  - `"add_longview": true`


To update your subscription plan, send a request to [Update Longview Plan](/docs/api/longview/#longview-plan-update).
 """,
    tags=['longview_plan_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_longview_plan():
    """
    Longview Plan View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/longview/plan',
    description=""" Update your Longview plan to that of the given subcription ID. This returns a `LongviewSubscription` object for the updated Longview Pro plan, or an empty set `{}` if the updated plan is Longview Free.

You must have `"longview_subscription": true` configured as a `global` [User Grant](/docs/api/account/#users-grants-view) in order to access this endpoint.

You can send a request to the [List Longview Subscriptions](/docs/api/longview/#longview-subscriptions-list) endpoint to receive the details, including `id`'s, of each plan.
 """,
    tags=['longview_plan_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_longview_plan(body: LongviewPlan):
    """
    Longview Plan Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/longview/subscriptions',
    description=""" Returns a paginated list of available Longview Subscriptions. This is a public endpoint and requires no authentication.
 """,
    tags=['longview_client_management', 'longview_plan_management'],
)
def get_longview_subscriptions(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Longview Subscriptions List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/longview/subscriptions/{subscriptionId}',
    description=""" Get the Longview plan details as a single `LongviewSubscription` object for the provided subscription ID. This is a public endpoint and requires no authentication.
 """,
    tags=['account_management', 'longview_client_management'],
)
def get_longview_subscription(subscription_id: str = Path(..., alias='subscriptionId')):
    """
    Longview Subscription View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/contacts',
    description=""" Returns a paginated list of Managed Contacts on your Account.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_contact_management', 'managed_contact_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_managed_contacts(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Managed Contacts List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/managed/contacts',
    description=""" Creates a Managed Contact.  A Managed Contact is someone Linode
special forces can contact in the course of attempting to resolve an issue
with a Managed Service.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_contact_management', 'managed_contact_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_managed_contact(body: ManagedContact = None):
    """
    Managed Contact Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/managed/contacts/{contactId}',
    description=""" Deletes a Managed Contact.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_contact_management', 'managed_contact_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_managed_contact(contact_id: int = Path(..., alias='contactId')):
    """
    Managed Contact Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/contacts/{contactId}',
    description=""" Returns a single Managed Contact.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_contact_management', 'managed_contact_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_managed_contact(contact_id: int = Path(..., alias='contactId')):
    """
    Managed Contact View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/managed/contacts/{contactId}',
    description=""" Updates information about a Managed Contact.
This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_contact_management', 'managed_contact_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_managed_contact(
    contact_id: int = Path(..., alias='contactId'), body: ManagedContact = ...
):
    """
    Managed Contact Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/credentials',
    description=""" Returns a paginated list of Managed Credentials on your Account.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_credential_operations', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_managed_credentials(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Managed Credentials List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/managed/credentials',
    description=""" Creates a Managed Credential. A Managed Credential is stored securely
to allow Linode special forces to access your Managed Services and resolve
issues.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_credential_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_managed_credential(body: ManagedCredentialsPostRequest = None):
    """
    Managed Credential Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/credentials/sshkey',
    description=""" Returns the unique SSH public key assigned to your Linode account's
Managed service. If you [add this public key](/docs/guides/linode-managed/#adding-the-public-key) to a Linode on your account,
Linode special forces will be able to log in to the Linode with this key
when attempting to resolve issues.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['ssh_key_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def view_managed_s_s_h_key():
    """
    Managed SSH Key View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/credentials/{credentialId}',
    description=""" Returns a single Managed Credential.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_credential_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_managed_credential(credential_id: int = Path(..., alias='credentialId')):
    """
    Managed Credential View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/managed/credentials/{credentialId}',
    description=""" Updates the label of a Managed Credential. This endpoint does not update the username and password for a Managed Credential. To do this, use the Managed Credential Username and Password Update ([POST /managed/credentials/{credentialId}/update](/docs/api/managed/#managed-credential-username-and-password-update)) endpoint instead.
This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_credential_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_managed_credential(
    credential_id: int = Path(..., alias='credentialId'), body: ManagedCredential = ...
):
    """
    Managed Credential Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/managed/credentials/{credentialId}/revoke',
    description=""" Deletes a Managed Credential.  Linode special forces will no longer
have access to this Credential when attempting to resolve issues.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_credential_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_managed_credential(credential_id: int = Path(..., alias='credentialId')):
    """
    Managed Credential Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/managed/credentials/{credentialId}/update',
    description=""" Updates the username and password for a Managed Credential.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_credential_operations', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_managed_credential_username_password(
    credential_id: int = Path(..., alias='credentialId'),
    body: ManagedCredentialsCredentialIdUpdatePostRequest = None,
):
    """
    Managed Credential Username and Password Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/issues',
    description=""" Returns a paginated list of recent and ongoing issues detected on your
Managed Services.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_issue_tracking'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_managed_issues(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Managed Issues List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/issues/{issueId}',
    description=""" Returns a single Issue that is impacting or did impact one of your
Managed Services.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_issue_tracking'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_managed_issue(issue_id: int = Path(..., alias='issueId')):
    """
    Managed Issue View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/linode-settings',
    description=""" Returns a paginated list of Managed Settings for your Linodes. There will
be one entry per Linode on your Account.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_linode_settings_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_managed_linode_settings(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Managed Linode Settings List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/linode-settings/{linodeId}',
    description=""" Returns a single Linode's Managed settings.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_linode_settings_operations', 'account_settings_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_managed_linode_setting(linode_id: int = Path(..., alias='linodeId')):
    """
    Linode's Managed Settings View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/managed/linode-settings/{linodeId}',
    description=""" Updates a single Linode's Managed settings.
This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_linode_settings_operations', 'linode_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_managed_linode_setting(
    linode_id: int = Path(..., alias='linodeId'), body: ManagedLinodeSettings = ...
):
    """
    Linode's Managed Settings Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/services',
    description=""" Returns a paginated list of Managed Services on your Account. These
are the services Linode Managed is monitoring and will report and attempt
to resolve issues with.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_service_management', 'managed_stats_retrieval'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_managed_services():
    """
    Managed Services List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/managed/services',
    description=""" Creates a Managed Service. Linode Managed will begin monitoring this
service and reporting and attempting to resolve any Issues.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_service_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_managed_service(body: ManagedServicesPostRequest = None):
    """
    Managed Service Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/managed/services/{serviceId}',
    description=""" Deletes a Managed Service.  This service will no longer be monitored by
Linode Managed.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_service_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_managed_service(service_id: int = Path(..., alias='serviceId')):
    """
    Managed Service Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/services/{serviceId}',
    description=""" Returns information about a single Managed Service on your Account.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_service_management', 'managed_stats_retrieval'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_managed_service(service_id: int = Path(..., alias='serviceId')):
    """
    Managed Service View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/managed/services/{serviceId}',
    description=""" Updates information about a Managed Service.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_service_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_managed_service(
    service_id: int = Path(..., alias='serviceId'), body: ManagedService = ...
):
    """
    Managed Service Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/managed/services/{serviceId}/disable',
    description=""" Temporarily disables monitoring of a Managed Service.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_service_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def disable_managed_service(service_id: int = Path(..., alias='serviceId')):
    """
    Managed Service Disable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/managed/services/{serviceId}/enable',
    description=""" Enables monitoring of a Managed Service.

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_service_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def enable_managed_service(service_id: int = Path(..., alias='serviceId')):
    """
    Managed Service Enable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/managed/stats',
    description=""" Returns a list of Managed Stats on your Account in the form of x and y data points.
You can use these data points to plot your own graph visualizations. These stats
reflect the last 24 hours of combined usage across all managed Linodes on your account
giving you a high-level snapshot of data for the following:


* cpu
* disk
* swap
* network in
* network out

This command can only be accessed by the unrestricted users of an account.
 """,
    tags=['managed_stats_retrieval'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_managed_stats():
    """
    Managed Stats List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networking/firewalls',
    description=""" Returns a paginated list of accessible Firewalls.
 """,
    tags=['firewall_management', 'firewall_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_firewalls(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Firewalls List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networking/firewalls',
    description=""" Creates a Firewall to filter network traffic.

* Use the `rules` property to create inbound and outbound access rules.

* Use the `devices` property to assign the Firewall to a service and apply its Rules to the device. Requires `read_write` [User's Grants](/docs/api/account/#users-grants-view) to the device.
Currently, Firewalls can only be assigned to Linode instances.

* A Firewall can be assigned to multiple Linode instances at a time.

* A Linode instance can have one active, assigned Firewall at a time.
Additional disabled Firewalls can be assigned to a service, but they cannot be enabled if another active Firewall is already assigned to the same service.

* A `firewall_create` Event is generated when this endpoint returns successfully.
 """,
    tags=['firewall_management', 'firewall_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_firewalls(body: NetworkingFirewallsPostRequest = None):
    """
    Firewall Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/networking/firewalls/{firewallId}',
    description=""" Delete a Firewall resource by its ID. This will remove all of the Firewall's Rules
from any Linode services that the Firewall was assigned to.

A `firewall_delete` Event is generated when this endpoint returns successfully.
 """,
    tags=['firewall_management', 'firewall_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_firewall(firewall_id: int = Path(..., alias='firewallId')):
    """
    Firewall Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networking/firewalls/{firewallId}',
    description=""" Get a specific Firewall resource by its ID. The Firewall's Devices will not be
returned in the response. Instead, use the
[List Firewall Devices](/docs/api/networking/#firewall-devices-list)
endpoint to review them.
 """,
    tags=['firewall_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_firewall(firewall_id: int = Path(..., alias='firewallId')):
    """
    Firewall View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/networking/firewalls/{firewallId}',
    description=""" Updates information for a Firewall. Some parts of a Firewall's configuration cannot
be manipulated by this endpoint:

- A Firewall's Devices cannot be set with this endpoint. Instead, use the
[Create Firewall Device](/docs/api/networking/#firewall-device-create)
and [Delete Firewall Device](/docs/api/networking/#firewall-device-delete)
endpoints to assign and remove this Firewall from Linode services.

- A Firewall's Rules cannot be changed with this endpoint. Instead, use the
[Update Firewall Rules](/docs/api/networking/#firewall-rules-update)
endpoint to update your Rules.

- A Firewall's status can be set to `enabled` or `disabled` by this endpoint, but it cannot be
set to `deleted`. Instead, use the
[Delete Firewall](/docs/api/networking/#firewall-delete)
endpoint to delete a Firewall.

If a Firewall's status is changed with this endpoint, a corresponding `firewall_enable` or
`firewall_disable` Event will be generated.
 """,
    tags=['firewall_management', 'firewall_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_firewall(
    firewall_id: int = Path(..., alias='firewallId'),
    body: NetworkingFirewallsFirewallIdPutRequest = None,
):
    """
    Firewall Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networking/firewalls/{firewallId}/devices',
    description=""" Returns a paginated list of a Firewall's Devices. A Firewall Device assigns a
Firewall to a Linode service (referred to as the Device's `entity`). Currently,
only Devices with an entity of type `linode` are accepted.
 """,
    tags=['firewall_management', 'firewall_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_firewall_devices(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    firewall_id: int = Path(..., alias='firewallId'),
):
    """
    Firewall Devices List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networking/firewalls/{firewallId}/devices',
    description=""" Creates a Firewall Device, which assigns a Firewall to a service (referred to
as the Device's `entity`) and applies the Firewall's Rules to the device.

* Currently, only Devices with an entity of type `linode` are accepted.

* A Firewall can be assigned to multiple Linode instances at a time.

* A Linode instance can have one active, assigned Firewall at a time.
Additional disabled Firewalls can be assigned to a service, but they cannot be enabled if another active Firewall is already assigned to the same service.

* A `firewall_device_add` Event is generated when the Firewall Device is added successfully.
 """,
    tags=['firewall_management', 'firewall_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_firewall_device(
    firewall_id: int = Path(..., alias='firewallId'),
    body: NetworkingFirewallsFirewallIdDevicesPostRequest = None,
):
    """
    Firewall Device Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/networking/firewalls/{firewallId}/devices/{deviceId}',
    description=""" Removes a Firewall Device, which removes a Firewall from the Linode service it was
assigned to by the Device. This will remove all of the Firewall's Rules from the Linode
service. If any other Firewalls have been assigned to the Linode service, then those Rules
will remain in effect.

A `firewall_device_remove` Event is generated when the Firewall Device is removed successfully.
 """,
    tags=['firewall_management', 'firewall_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_firewall_device(
    firewall_id: int = Path(..., alias='firewallId'),
    device_id: int = Path(..., alias='deviceId'),
):
    """
    Firewall Device Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networking/firewalls/{firewallId}/devices/{deviceId}',
    description=""" Returns information for a Firewall Device, which assigns a Firewall
to a Linode service (referred to as the Device's `entity`). Currently,
only Devices with an entity of type `linode` are accepted.
 """,
    tags=['firewall_management', 'firewall_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_firewall_device(
    firewall_id: int = Path(..., alias='firewallId'),
    device_id: int = Path(..., alias='deviceId'),
):
    """
    Firewall Device View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networking/firewalls/{firewallId}/rules',
    description=""" Returns the inbound and outbound Rules for a Firewall.
 """,
    tags=['firewall_management', 'firewall_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_firewall_rules(firewall_id: int = Path(..., alias='firewallId')):
    """
    Firewall Rules List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/networking/firewalls/{firewallId}/rules',
    description=""" Updates the inbound and outbound Rules for a Firewall.

**Note:** This command replaces all of a Firewall's `inbound` and/or `outbound` rulesets with the values specified in your request.
 """,
    tags=['firewall_management', 'firewall_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_firewall_rules(
    firewall_id: int = Path(..., alias='firewallId'),
    body: NetworkingFirewallsFirewallIdRulesPutRequest = None,
):
    """
    Firewall Rules Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networking/ips',
    description=""" Returns a paginated list of IP Addresses on your Account, excluding private addresses.
 """,
    tags=['ip_address_management', 'linode_ip_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_i_ps():
    """
    IP Addresses List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networking/ips',
    description=""" Allocates a new IPv4 Address on your Account. The Linode must be configured to support additional addresses - please [open a support ticket](/docs/api/support/#support-ticket-open) requesting additional addresses before attempting allocation.
 """,
    tags=['ip_address_management', 'linode_ip_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def allocate_i_p(body: NetworkingIpsPostRequest):
    """
    IP Address Allocate
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networking/ips/assign',
    description=""" Assign multiple IPv4 addresses and/or IPv6 ranges to multiple Linodes in one Region. This allows swapping, shuffling, or otherwise reorganizing IPs to your Linodes.

The following restrictions apply:
* All Linodes involved must have at least one public IPv4 address after assignment.
* Linodes may have no more than one assigned private IPv4 address.
* Linodes may have no more than one assigned IPv6 range.

[Open a Support Ticket](/docs/api/support/#support-ticket-open) to request additional IPv4 addresses or IPv6 ranges beyond standard account limits.

**Note**: Removing an IP address that has been set as a Managed Linode's `ssh.ip` causes the Managed Linode's SSH access settings to reset to their default values. To view and configure Managed Linode SSH settings, use the following commands:
* **Linode's Managed Settings View** ([GET /managed/linode-settings/{linodeId}](/docs/api/managed/#linodes-managed-settings-view))
* **Linode's Managed Settings Update** ([PUT /managed/linode-settings/{linodeId}](/docs/api/managed/#linodes-managed-settings-update))
 """,
    tags=['ip_address_management', 'linode_ip_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def assign_i_ps(body: IPAddressesAssignRequest):
    """
    IP Addresses Assign
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networking/ips/share',
    description=""" Configure shared IPs.

IP sharing allows IP address reassignment (also referred to as IP failover) from one Linode to another if the primary Linode becomes unresponsive. This means that requests to the primary Linode's IP address can be automatically rerouted to secondary Linodes at the configured shared IP addresses.

IP failover requires configuration of a failover service (such as [Keepalived](/docs/guides/ip-failover-keepalived)) within the internal system of the primary Linode.
 """,
    tags=['ip_address_management', 'linode_ip_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def share_i_ps(body: IPAddressesShareRequest):
    """
    IP Addresses Share
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networking/ips/{address}',
    description=""" Returns information about a single IP Address on your Account.
 """,
    tags=['ip_address_management', 'linode_ip_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_i_p(address: str):
    """
    IP Address View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/networking/ips/{address}',
    description=""" Sets RDNS on an IP Address. Forward DNS must already be set up for reverse DNS to be applied. If you set the RDNS to `null` for public IPv4 addresses, it will be reset to the default _ip.linodeusercontent.com_ RDNS value.
 """,
    tags=['ip_address_management', 'linode_ip_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_i_p(address: str, body: NetworkingIpsAddressPutRequest = ...):
    """
    IP Address RDNS Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networking/ipv4/assign',
    description=""" This command is equivalent to **IP Addresses Assign** ([POST /networking/ips/assign](#ip-addresses-assign)).

Assign multiple IPv4 addresses and/or IPv6 ranges to multiple Linodes in one Region. This allows swapping, shuffling, or otherwise reorganizing IPs to your Linodes.

The following restrictions apply:
* All Linodes involved must have at least one public IPv4 address after assignment.
* Linodes may have no more than one assigned private IPv4 address.
* Linodes may have no more than one assigned IPv6 range.

[Open a Support Ticket](/docs/api/support/#support-ticket-open) to request additional IPv4 addresses or IPv6 ranges beyond standard account limits.

**Note**: Removing an IP address that has been set as a Managed Linode's `ssh.ip` causes the Managed Linode's SSH access settings to reset to their default values. To view and configure Managed Linode SSH settings, use the following commands:
* **Linode's Managed Settings View** ([GET /managed/linode-settings/{linodeId}](/docs/api/managed/#linodes-managed-settings-view))
* **Linode's Managed Settings Update** ([PUT /managed/linode-settings/{linodeId}](/docs/api/managed/#linodes-managed-settings-update))
 """,
    tags=['ip_address_management', 'linode_ip_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def assign_i_pv4s(body: IPAddressesAssignRequest):
    """
    Linodes Assign IPv4s
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networking/ipv4/share',
    description=""" This command is equivalent to **IP Addresses Share** ([POST /networking/ips/share](#ip-addresses-share)).

Configure shared IPs.

IP sharing allows IP address reassignment (also referred to as IP failover) from one Linode to another if the primary Linode becomes unresponsive. This means that requests to the primary Linode's IP address can be automatically rerouted to secondary Linodes at the configured shared IP addresses.

IP failover requires configuration of a failover service (such as [Keepalived](/docs/guides/ip-failover-keepalived)) within the internal system of the primary Linode.
 """,
    tags=['ip_address_management', 'linode_ip_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def share_i_pv4s(body: IPAddressesShareRequest):
    """
    IPv4 Sharing Configure
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networking/ipv6/pools',
    description=""" Displays the IPv6 pools on your Account. A pool of IPv6 addresses are routed to all of your Linodes in a single [Region](/docs/api/regions/#regions-list). Any Linode on your Account may bring up any address in this pool at any time, with no external configuration required.
 """,
    tags=['ipv6_networking'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_i_pv6_pools(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    IPv6 Pools List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networking/ipv6/ranges',
    description=""" Displays the IPv6 ranges on your Account.


  * An IPv6 range is a `/64` or `/54` block of IPv6 addresses routed to a single Linode in a given [Region](/docs/api/regions/#regions-list).

  * Your Linode is responsible for routing individual addresses in the range, or handling traffic for all the addresses in the range.

  * Access the IPv6 Range Create ([POST /networking/ipv6/ranges](/docs/api/networking/#ipv6-range-create)) endpoint to add a `/64` or `/56` block of IPv6 addresses to your account.
 """,
    tags=['ipv6_networking'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_i_pv6_ranges(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    IPv6 Ranges List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networking/ipv6/ranges',
    description=""" Creates an IPv6 Range and assigns it based on the provided Linode or route target IPv6 SLAAC address. See the `ipv6` property when accessing the Linode View ([GET /linode/instances/{linodeId}](/docs/api/linode-instances/#linode-view)) endpoint to view a Linode's IPv6 SLAAC address.
  * Either `linode_id` or `route_target` is required in a request.
  * `linode_id` and `route_target` are mutually exclusive. Submitting values for both properties in a request results in an error.
  * Upon a successful request, an IPv6 range is created in the [Region](/docs/api/regions/#regions-list) that corresponds to the provided `linode_id` or `route_target`.
  * Your Linode is responsible for routing individual addresses in the range, or handling traffic for all the addresses in the range.
  * Access the IP Addresses Assign ([POST /networking/ips/assign](/docs/api/networking/#ip-addresses-assign)) endpoint to re-assign IPv6 Ranges to your Linodes.

**Note**: The following restrictions apply:
  * A Linode can only have one IPv6 range targeting its SLAAC address.
  * An account can only have one IPv6 range in each [Region](/docs/api/regions/#regions-list).
  * [Open a Support Ticket](/docs/api/support/#support-ticket-open) to request expansion of these restrictions.
 """,
    tags=['ipv6_networking'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_i_pv6_range(body: NetworkingIpv6RangesPostRequest):
    """
    IPv6 Range Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/networking/ipv6/ranges/{range}',
    description=""" Removes this IPv6 range from your account and disconnects the range from any assigned Linodes.

**Note:** Shared IPv6 ranges cannot be deleted at this time. Please contact Customer Support for assistance.
 """,
    tags=['ipv6_networking'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_i_pv6_range(range: IPv6Address):
    """
    IPv6 Range Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networking/ipv6/ranges/{range}',
    description=""" View IPv6 range information.
 """,
    tags=['ipv6_networking'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_i_pv6_range(range: IPv6Address):
    """
    IPv6 Range View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networking/vlans',
    description=""" Returns a list of all Virtual Local Area Networks (VLANs) on your Account. VLANs provide
a mechanism for secure communication between two or more Linodes that are assigned to the
same VLAN and are both within the same Layer 2 broadcast domain.

VLANs are created and attached to Linodes by using the `interfaces` property for the following endpoints:

- Linode Create ([POST /linode/instances](/docs/api/linode-instances/#linode-create))
- Configuration Profile Create ([POST /linode/instances/{linodeId}/configs](/docs/api/linode-instances/#configuration-profile-create))
- Configuration Profile Update ([PUT /linode/instances/{linodeId}/configs/{configId}](/docs/api/linode-instances/#configuration-profile-update))

There are several ways to detach a VLAN from a Linode:

- [Update](/docs/api/linode-instances/#configuration-profile-update) the active Configuration Profile to remove the VLAN interface, then [reboot](/docs/api/linode-instances/#linode-reboot) the Linode.
- [Create](/docs/api/linode-instances/#configuration-profile-create) a new Configuration Profile without the VLAN interface, then [reboot](/docs/api/linode-instances/#linode-reboot) the Linode into the new Configuration Profile.
- [Delete](/docs/api/linode-instances/#linode-delete) the Linode.

**Note:** Only Next Generation Network (NGN) data centers support VLANs. Use the Regions ([/regions](/docs/api/regions/)) endpoint to view the capabilities of data center regions.
If a VLAN is attached to your Linode and you attempt to migrate or clone it to a non-NGN data center,
the migration or cloning will not initiate. If a Linode cannot be migrated because of an incompatibility,
you will be prompted to select a different data center or contact support.

**Note:** See the [VLANs Overview](/docs/products/networking/vlans/#technical-specifications) to view additional specifications and limitations.
 """,
    tags=['managed_database_operations', 'database_type_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_v_l_a_ns(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    VLANs List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/nodebalancers',
    description=""" Returns a paginated list of NodeBalancers you have access to.
 """,
    tags=['node_balancer_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_node_balancers(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    NodeBalancers List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/nodebalancers',
    description=""" Creates a NodeBalancer in the requested Region.

NodeBalancers require a port Config with at least one backend Node to start serving requests.

When using the Linode CLI to create a NodeBalancer, first create a NodeBalancer without any Configs. Then, create Configs and Nodes for that NodeBalancer with the respective [Config Create](/docs/api/nodebalancers/#config-create) and [Node Create](/docs/api/nodebalancers/#node-create) commands.
 """,
    tags=['node_balancer_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_node_balancer(body: NodebalancersPostRequest):
    """
    NodeBalancer Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/nodebalancers/{nodeBalancerId}',
    description=""" Deletes a NodeBalancer.

**This is a destructive action and cannot be undone.**

Deleting a NodeBalancer will also delete all associated Configs and Nodes, although the backend servers represented by the Nodes will not be changed or removed. Deleting a NodeBalancer will cause you to lose access to the IP Addresses assigned to this NodeBalancer.
 """,
    tags=['node_balancer_management', 'node_balancer_nodes_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_node_balancer(node_balancer_id: int = Path(..., alias='nodeBalancerId')):
    """
    NodeBalancer Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/nodebalancers/{nodeBalancerId}',
    description=""" Returns a single NodeBalancer you can access.
 """,
    tags=['node_balancer_management', 'node_balancer_configs_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_node_balancer(node_balancer_id: int = Path(..., alias='nodeBalancerId')):
    """
    NodeBalancer View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/nodebalancers/{nodeBalancerId}',
    description=""" Updates information about a NodeBalancer you can access.
 """,
    tags=[
        'node_balancer_management',
        'node_balancer_configs_management',
        'node_balancer_nodes_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_node_balancer(
    node_balancer_id: int = Path(..., alias='nodeBalancerId'), body: NodeBalancer = ...
):
    """
    NodeBalancer Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/nodebalancers/{nodeBalancerId}/configs',
    description=""" Returns a paginated list of NodeBalancer Configs associated with this NodeBalancer. NodeBalancer Configs represent individual ports that this NodeBalancer will accept traffic on, one Config per port.

For example, if you wanted to accept standard HTTP traffic, you would need a Config listening on port 80.
 """,
    tags=['node_balancer_configs_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_node_balancer_configs(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    node_balancer_id: int = Path(..., alias='nodeBalancerId'),
):
    """
    Configs List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/nodebalancers/{nodeBalancerId}/configs',
    description=""" Creates a NodeBalancer Config, which allows the NodeBalancer to accept traffic on a new port. You will need to add NodeBalancer Nodes to the new Config before it can actually serve requests.
 """,
    tags=['node_balancer_configs_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_node_balancer_config(
    node_balancer_id: int = Path(..., alias='nodeBalancerId'),
    body: NodeBalancerConfig = None,
):
    """
    Config Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/nodebalancers/{nodeBalancerId}/configs/{configId}',
    description=""" Deletes the Config for a port of this NodeBalancer.

**This cannot be undone.**

Once completed, this NodeBalancer will no longer respond to requests on the given port. This also deletes all associated NodeBalancerNodes, but the Linodes they were routing traffic to will be unchanged and will not be removed.
 """,
    tags=['node_balancer_management', 'node_balancer_configs_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_node_balancer_config(
    node_balancer_id: int = Path(..., alias='nodeBalancerId'),
    config_id: int = Path(..., alias='configId'),
):
    """
    Config Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/nodebalancers/{nodeBalancerId}/configs/{configId}',
    description=""" Returns configuration information for a single port of this NodeBalancer.
 """,
    tags=['node_balancer_management', 'node_balancer_configs_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_node_balancer_config(
    node_balancer_id: int = Path(..., alias='nodeBalancerId'),
    config_id: int = Path(..., alias='configId'),
):
    """
    Config View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/nodebalancers/{nodeBalancerId}/configs/{configId}',
    description=""" Updates the configuration for a single port on a NodeBalancer.
 """,
    tags=['node_balancer_management', 'node_balancer_configs_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_node_balancer_config(
    node_balancer_id: int = Path(..., alias='nodeBalancerId'),
    config_id: int = Path(..., alias='configId'),
    body: NodeBalancerConfig = ...,
):
    """
    Config Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes',
    description=""" Returns a paginated list of NodeBalancer nodes associated with this Config. These are the backends that will be sent traffic for this port.
 """,
    tags=[
        'node_balancer_management',
        'node_balancer_configs_management',
        'node_balancer_nodes_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_node_balancer_config_nodes(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    node_balancer_id: int = Path(..., alias='nodeBalancerId'),
    config_id: int = Path(..., alias='configId'),
):
    """
    Nodes List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes',
    description=""" Creates a NodeBalancer Node, a backend that can accept traffic for this NodeBalancer Config. Nodes are routed requests on the configured port based on their status.
 """,
    tags=[
        'node_balancer_management',
        'node_balancer_configs_management',
        'node_balancer_nodes_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_node_balancer_node(
    node_balancer_id: int = Path(..., alias='nodeBalancerId'),
    config_id: int = Path(..., alias='configId'),
    body: NodebalancersNodeBalancerIdConfigsConfigIdNodesPostRequest = ...,
):
    """
    Node Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}',
    description=""" Deletes a Node from this Config. This backend will no longer receive traffic for the configured port of this NodeBalancer.

This does not change or remove the Linode whose address was used in the creation of this Node.
 """,
    tags=['node_balancer_nodes_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_node_balancer_config_node(
    node_balancer_id: int = Path(..., alias='nodeBalancerId'),
    config_id: int = Path(..., alias='configId'),
    node_id: int = Path(..., alias='nodeId'),
):
    """
    Node Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}',
    description=""" Returns information about a single Node, a backend for this NodeBalancer's configured port.
 """,
    tags=[
        'node_balancer_management',
        'node_balancer_configs_management',
        'node_balancer_nodes_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_node_balancer_node(
    node_balancer_id: int = Path(..., alias='nodeBalancerId'),
    config_id: int = Path(..., alias='configId'),
    node_id: int = Path(..., alias='nodeId'),
):
    """
    Node View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}',
    description=""" Updates information about a Node, a backend for this NodeBalancer's configured port.
 """,
    tags=[
        'node_balancer_management',
        'node_balancer_nodes_management',
        'node_balancer_configs_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_node_balancer_node(
    node_balancer_id: int = Path(..., alias='nodeBalancerId'),
    config_id: int = Path(..., alias='configId'),
    node_id: int = Path(..., alias='nodeId'),
    body: NodeBalancerNode = ...,
):
    """
    Node Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/nodebalancers/{nodeBalancerId}/configs/{configId}/rebuild',
    description=""" Rebuilds a NodeBalancer Config and its Nodes that you have permission to modify.

Use this command to update a NodeBalancer's Config and Nodes with a single request.
 """,
    tags=['node_balancer_management', 'node_balancer_configs_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def rebuild_node_balancer_config(
    node_balancer_id: int = Path(..., alias='nodeBalancerId'),
    config_id: int = Path(..., alias='configId'),
    body: NodebalancersNodeBalancerIdConfigsConfigIdRebuildPostRequest = ...,
):
    """
    Config Rebuild
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/nodebalancers/{nodeBalancerId}/stats',
    description=""" Returns detailed statistics about the requested NodeBalancer.
 """,
    tags=['node_balancer_management', 'node_balancer_statistics_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_nodebalancers__node_balancer_id_stats(
    node_balancer_id: int = Path(..., alias='nodeBalancerId')
):
    """
    NodeBalancer Statistics View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/object-storage/buckets',
    description=""" Returns a paginated list of all Object Storage Buckets that you own.


This endpoint is available for convenience. It is recommended that instead you
use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/serviceops/#list-buckets) directly.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_object_storage_buckets():
    """
    Object Storage Buckets List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/object-storage/buckets',
    description=""" Creates an Object Storage Bucket in the specified cluster.

Accounts with negative balances cannot access this command.

If the bucket already exists and is owned by you, this endpoint returns a `200` response with that bucket as if it had just been created.

This endpoint is available for convenience. It is recommended that instead you use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#put-bucket) directly.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_object_storage_bucket(body: ObjectStorageBucketsPostRequest = None):
    """
    Object Storage Bucket Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/object-storage/buckets/{clusterId}',
    description=""" Returns a list of Buckets in this cluster belonging to this Account.


This endpoint is available for convenience. It is recommended that instead you
use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#get-bucket) directly.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_object_storage_bucketin_cluster(cluster_id: str = Path(..., alias='clusterId')):
    """
    Object Storage Buckets in Cluster List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/object-storage/buckets/{clusterId}/{bucket}',
    description=""" Removes a single bucket.

Bucket objects must be removed prior to removing the bucket. While buckets containing objects _may_ be
deleted using the [s3cmd command-line tool](/docs/products/storage/object-storage/guides/s3cmd/#delete-a-bucket), such operations
can fail if the bucket contains too many objects. The recommended
way to empty large buckets is to use the [S3 API to configure lifecycle policies](https://docs.ceph.com/en/latest/radosgw/bucketpolicy/#) that
remove all objects, then delete the bucket.

This endpoint is available for convenience. It is recommended that instead you
use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#delete-bucket) directly.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_object_storage_bucket(
    cluster_id: str = Path(..., alias='clusterId'), bucket: str = ...
):
    """
    Object Storage Bucket Remove
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/object-storage/buckets/{clusterId}/{bucket}',
    description=""" Returns a single Object Storage Bucket.


This endpoint is available for convenience. It is recommended that instead you
use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#get-bucket) directly.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_object_storage_bucket(
    cluster_id: str = Path(..., alias='clusterId'), bucket: str = ...
):
    """
    Object Storage Bucket View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/object-storage/buckets/{clusterId}/{bucket}/access',
    description=""" Allows changing basic Cross-origin Resource Sharing (CORS) and Access Control Level (ACL) settings.
Only allows enabling/disabling CORS for all origins, and/or setting canned ACLs.


For more fine-grained control of both systems, please use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#put-bucket-acl) directly.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def modify_object_storage_bucket_access(
    cluster_id: str = Path(..., alias='clusterId'),
    bucket: str = ...,
    body: ObjectStorageBucketsClusterIdBucketAccessPostRequest = None,
):
    """
    Object Storage Bucket Access Modify
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/object-storage/buckets/{clusterId}/{bucket}/access',
    description=""" Allows changing basic Cross-origin Resource Sharing (CORS) and Access Control Level (ACL) settings.
Only allows enabling/disabling CORS for all origins, and/or setting canned ACLs.


For more fine-grained control of both systems, please use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/bucketops/#put-bucket-acl) directly.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_object_storage_bucket_access(
    cluster_id: str = Path(..., alias='clusterId'),
    bucket: str = ...,
    body: ObjectStorageBucketsClusterIdBucketAccessPutRequest = None,
):
    """
    Object Storage Bucket Access Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/object-storage/buckets/{clusterId}/{bucket}/object-acl',
    description=""" View an Object's configured Access Control List (ACL) in this Object Storage bucket.
ACLs define who can access your buckets and objects and specify the level of access
granted to those users.


This endpoint is available for convenience. It is recommended that instead you
use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/objectops/#get-object-acl) directly.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def view_object_storage_bucket_a_c_l(
    name: str, cluster_id: str = Path(..., alias='clusterId'), bucket: str = ...
):
    """
    Object Storage Object ACL Config View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/object-storage/buckets/{clusterId}/{bucket}/object-acl',
    description=""" Update an Object's configured Access Control List (ACL) in this Object Storage bucket.
ACLs define who can access your buckets and objects and specify the level of access
granted to those users.


This endpoint is available for convenience. It is recommended that instead you
use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/objectops/#set-object-acl) directly.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_object_storage_bucket_a_c_l(
    cluster_id: str = Path(..., alias='clusterId'),
    bucket: str = ...,
    body: ObjectStorageBucketsClusterIdBucketObjectAclPutRequest = None,
):
    """
    Object Storage Object ACL Config Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/object-storage/buckets/{clusterId}/{bucket}/object-list',
    description=""" Returns the contents of a bucket. The contents are paginated using a `marker`,
which is the name of the last object on the previous page.  Objects may
be filtered by `prefix` and `delimiter` as well; see Query Parameters for more
information.


This endpoint is available for convenience. It is recommended that instead you
use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/objectops/#get-object) directly.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_object_storage_bucket_content(
    marker: Optional[str] = None,
    delimiter: Optional[str] = None,
    prefix: Optional[str] = None,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    cluster_id: str = Path(..., alias='clusterId'),
    bucket: str = ...,
):
    """
    Object Storage Bucket Contents List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/object-storage/buckets/{clusterId}/{bucket}/object-url',
    description=""" Creates a pre-signed URL to access a single Object in a bucket. This
can be used to share objects, and also to create/delete objects by using
the appropriate HTTP method in your request body's `method` parameter.


This endpoint is available for convenience. It is recommended that instead you
use the more [fully-featured S3 API](https://docs.ceph.com/en/latest/radosgw/s3/)
directly.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_object_storage_object_u_r_l(
    cluster_id: str = Path(..., alias='clusterId'),
    bucket: str = ...,
    body: ObjectStorageBucketsClusterIdBucketObjectUrlPostRequest = None,
):
    """
    Object Storage Object URL Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/object-storage/buckets/{clusterId}/{bucket}/ssl',
    description=""" Deletes this Object Storage bucket's user uploaded TLS/SSL certificate and private key.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_object_storage_s_s_l(
    cluster_id: str = Path(..., alias='clusterId'), bucket: str = ...
):
    """
    Object Storage TLS/SSL Cert Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/object-storage/buckets/{clusterId}/{bucket}/ssl',
    description=""" Returns a boolean value indicating if this bucket has a corresponding TLS/SSL certificate that was
uploaded by an Account user.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_object_storage_s_s_l(
    cluster_id: str = Path(..., alias='clusterId'), bucket: str = ...
):
    """
    Object Storage TLS/SSL Cert View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/object-storage/buckets/{clusterId}/{bucket}/ssl',
    description=""" Upload a TLS/SSL certificate and private key to be served when you visit your Object Storage bucket via HTTPS.
Your TLS/SSL certificate and private key are stored encrypted at rest.


To replace an expired certificate, [delete your current certificate](/docs/api/object-storage/#object-storage-tlsssl-cert-delete)
and upload a new one.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_object_storage_s_s_l(
    cluster_id: str = Path(..., alias='clusterId'),
    bucket: str = ...,
    body: ObjectStorageSSL = None,
):
    """
    Object Storage TLS/SSL Cert Upload
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/object-storage/cancel',
    description=""" Cancel Object Storage on an Account.

**Warning**: Removes all buckets and their contents from your Account. This data is irretrievable once removed.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def cancel_object_storage():
    """
    Object Storage Cancel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/object-storage/clusters',
    description=""" Returns a paginated list of Object Storage Clusters that are available for
use.  Users can connect to the clusters with third party clients to create buckets
and upload objects.
 """,
    tags=['account_management', 'user_management'],
)
def get_object_storage_clusters():
    """
    Clusters List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/object-storage/clusters/{clusterId}',
    description=""" Returns a single Object Storage Cluster.
 """,
    tags=['managed_service_management'],
)
def get_object_storage_cluster(cluster_id: str = Path(..., alias='clusterId')):
    """
    Cluster View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/object-storage/keys',
    description=""" Returns a paginated list of Object Storage Keys for authenticating to
the Object Storage S3 API.
 """,
    tags=['object_storage_management', 'object_storage_keys_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_object_storage_keys():
    """
    Object Storage Keys List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/object-storage/keys',
    description=""" Provisions a new Object Storage Key on your account.

Accounts with negative balances cannot access this command.

* To create a Limited Access Key with specific permissions, send a `bucket_access` array.

* To create a Limited Access Key without access to any buckets, send an empty `bucket_access` array.

* To create an Access Key with unlimited access to all clusters and all buckets, omit the `bucket_access` array.
 """,
    tags=['object_storage_management', 'object_storage_keys_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_object_storage_keys(body: ObjectStorageKey = None):
    """
    Object Storage Key Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/object-storage/keys/{keyId}',
    description=""" Revokes an Object Storage Key.  This keypair will no longer be usable by third-party clients.
 """,
    tags=['object_storage_keys_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_object_storage_key(key_id: int = Path(..., alias='keyId')):
    """
    Object Storage Key Revoke
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/object-storage/keys/{keyId}',
    description=""" Returns a single Object Storage Key provisioned for your account.
 """,
    tags=['object_storage_management', 'object_storage_keys_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_object_storage_key(key_id: int = Path(..., alias='keyId')):
    """
    Object Storage Key View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/object-storage/keys/{keyId}',
    description=""" Updates an Object Storage Key on your account.
 """,
    tags=['object_storage_keys_management', 'object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_object_storage_key(
    key_id: int = Path(..., alias='keyId'),
    body: ObjectStorageKeysKeyIdPutRequest = None,
):
    """
    Object Storage Key Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/object-storage/transfer',
    description=""" The amount of outbound data transfer used by your account's Object Storage buckets.
Object Storage adds 1 terabyte of outbound data transfer to your data transfer pool.
See the [Object Storage Overview](/docs/products/storage/object-storage/#pricing)
guide for details on Object Storage transfer quotas.
 """,
    tags=['object_storage_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_object_storage_transfer():
    """
    Object Storage Transfer View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile',
    description=""" Returns information about the current User. This can be used to see who is acting in applications where more than one token is managed. For example, in third-party OAuth applications.

This endpoint is always accessible, no matter what OAuth scopes the acting token has.
 """,
    tags=['user_profile_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_profile():
    """
    Profile View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/profile',
    description=""" Update information in your Profile.  This endpoint requires the "account:read_write" OAuth Scope.
 """,
    tags=['user_profile_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_profile(body: Profile):
    """
    Profile Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/apps',
    description=""" This is a collection of OAuth apps that you've given access to your Account, and includes the level of access granted.
 """,
    tags=['profile_app_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_profile_apps(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Authorized Apps List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/profile/apps/{appId}',
    description=""" Expires this app token. This token may no longer be used to access your Account.
 """,
    tags=['profile_app_management', 'trusted_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_profile_app(app_id: int = Path(..., alias='appId')):
    """
    App Access Revoke
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/apps/{appId}',
    description=""" Returns information about a single app you've authorized to access your Account.
 """,
    tags=[
        'user_profile_management',
        'profile_app_management',
        'profile_login_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_profile_app(app_id: int = Path(..., alias='appId')):
    """
    Authorized App View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/devices',
    description=""" Returns a paginated list of active TrustedDevices for your User. Browsers with an active Remember Me Session are logged into your account until the session expires or is revoked.
 """,
    tags=['trusted_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_devices():
    """
    Trusted Devices List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/profile/devices/{deviceId}',
    description=""" Revoke an active TrustedDevice for your User.  Once a TrustedDevice is revoked, this device will have to log in again before accessing your Linode account.
 """,
    tags=['trusted_device_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def revoke_trusted_device(device_id: int = Path(..., alias='deviceId')):
    """
    Trusted Device Revoke
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/devices/{deviceId}',
    description=""" Returns a single active TrustedDevice for your User.
 """,
    tags=['trusted_device_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_trusted_device(device_id: int = Path(..., alias='deviceId')):
    """
    Trusted Device View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/grants',
    description=""" This returns a GrantsResponse describing what the acting User has been granted access to.  For unrestricted users, this will return a  204 and no body because unrestricted users have access to everything without grants.  This will not return information about entities you do not have access to.  This endpoint is useful when writing third-party OAuth applications to see what options you should present to the acting User.

For example, if they do not have `global.add_linodes`, you might not display a button to deploy a new Linode.

Any client may access this endpoint; no OAuth scopes are required.
 """,
    tags=['user_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_profile_grants():
    """
    Grants List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/logins',
    description=""" Returns a collection of successful account logins from this user during the last 90 days.
 """,
    tags=['user_login_management', 'profile_login_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_profile_logins():
    """
    Logins List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/logins/{loginId}',
    description=""" Returns a login object displaying information about a successful account login from this user.
 """,
    tags=['user_login_management', 'profile_login_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_profile_login(login_id: int = Path(..., alias='loginId')):
    """
    Login View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/profile/phone-number',
    description=""" Delete the verified phone number for the User making this request.

Use this command to opt out of SMS messages for the requesting User after a phone number has been verified with the **Phone Number Verify** ([POST /profile/phone-number/verify](/docs/api/profile/#phone-number-verify)) command.
 """,
    tags=['phone_number_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_profile_phone_number():
    """
    Phone Number Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/profile/phone-number',
    description=""" Send a one-time verification code via SMS message to the submitted phone number. Providing your phone number helps ensure you can securely access your Account in case other ways to connect are lost. Your phone number is only used to verify your identity by sending an SMS message. Standard carrier messaging fees may apply.

* By accessing this command you are opting in to receive SMS messages. You can opt out of SMS messages by using the **Phone Number Delete** ([DELETE /profile/phone-number](/docs/api/profile/#phone-number-delete)) command after your phone number is verified.

* Verification codes are valid for 10 minutes after they are sent.

* Subsequent requests made prior to code expiration result in sending the same code.

Once a verification code is received, verify your phone number with the **Phone Number Verify** ([POST /profile/phone-number/verify](/docs/api/profile/#phone-number-verify)) command.
 """,
    tags=['phone_number_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_profile_phone_number(body: ProfilePhoneNumberPostRequest = None):
    """
    Phone Number Verification Code Send
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/profile/phone-number/verify',
    description=""" Verify a phone number by confirming the one-time code received via SMS message after accessing the **Phone Verification Code Send** ([POST /profile/phone-number](/docs/api/profile/#phone-number-verification-code-send)) command.

* Verification codes are valid for 10 minutes after they are sent.

* Only the same User that made the verification code request can use that code with this command.

Once completed, the verified phone number is assigned to the User making the request. To change the verified phone number for a User, first use the **Phone Number Delete** ([DELETE /profile/phone-number](/docs/api/profile/#phone-number-delete)) command, then begin the verification process again with the **Phone Verification Code Send** ([POST /profile/phone-number](/docs/api/profile/#phone-number-verification-code-send)) command.
 """,
    tags=['phone_number_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_profile_phone_number_verify(body: ProfilePhoneNumberVerifyPostRequest = None):
    """
    Phone Number Verify
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/preferences',
    description=""" View a list of user preferences tied to the OAuth client that generated
the token making the request. The user preferences endpoints allow
consumers of the API to store arbitrary JSON data, such as a user's font
size preference or preferred display name. User preferences are available
for each OAuth client registered to your account, and as such an account can
have multiple user preferences.
 """,
    tags=['user_preferences_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_user_preferences():
    """
    User Preferences View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/profile/preferences',
    description=""" Updates a user's preferences. These preferences are tied to the OAuth client that generated the token making the request. The user preferences endpoints allow consumers of the API to store arbitrary JSON data, such as a user's font size preference or preferred display name. An account may have multiple preferences. Preferences, and the pertaining request body, may contain any arbitrary JSON data that the user would like to store.
 """,
    tags=['user_preferences_management', 'account_settings_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_user_preferences(body: ProfilePreferencesPutRequest):
    """
    User Preferences Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/security-questions',
    description=""" Returns a collection of security questions and their responses, if any, for your User Profile.
 """,
    tags=['security_question_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_security_questions():
    """
    Security Questions List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/profile/security-questions',
    description=""" Adds security question responses for your User.

Requires exactly three unique questions.

Previous responses are overwritten if answered or reset to `null` if unanswered.

**Note**: Security questions must be answered for your User prior to accessing the **Two Factor Secret Create** ([POST /profile/tfa-enable](/docs/api/profile/#two-factor-secret-create)) command.
 """,
    tags=['security_question_management', 'account_management', 'user_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_security_questions(body: SecurityQuestionsPost = None):
    """
    Security Questions Answer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/sshkeys',
    description=""" Returns a collection of SSH Keys you've added to your Profile.
 """,
    tags=['ssh_key_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_s_s_h_keys(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    SSH Keys List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/profile/sshkeys',
    description=""" Adds an SSH Key to your Account profile.
 """,
    tags=['ssh_key_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_s_s_h_key(body: SSHKey = None):
    """
    SSH Key Add
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/profile/sshkeys/{sshKeyId}',
    description=""" Deletes an SSH Key you have access to.

**Note:** deleting an SSH Key will *not* remove it from any Linode or Disk that was deployed with `authorized_keys`. In those cases, the keys must be manually deleted on the Linode or Disk. This endpoint will only delete the key's association from your Profile.
 """,
    tags=['ssh_key_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_s_s_h_key(ssh_key_id: int = Path(..., alias='sshKeyId')):
    """
    SSH Key Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/sshkeys/{sshKeyId}',
    description=""" Returns a single SSH Key object identified by `id` that you have access to view.
 """,
    tags=['ssh_key_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_s_s_h_key(ssh_key_id: int = Path(..., alias='sshKeyId')):
    """
    SSH Key View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/profile/sshkeys/{sshKeyId}',
    description=""" Updates an SSH Key that you have permission to `read_write`.

Only SSH key labels can be updated.
 """,
    tags=['ssh_key_management', 'user_profile_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_s_s_h_key(
    ssh_key_id: int = Path(..., alias='sshKeyId'),
    body: ProfileSshkeysSshKeyIdPutRequest = ...,
):
    """
    SSH Key Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/profile/tfa-disable',
    description=""" Disables Two Factor Authentication for your User. Once successful, login attempts from untrusted computers will only require a password before being successful. This is less secure, and is discouraged.
 """,
    tags=[
        'account_management',
        'account_settings_management',
        'two_factor_authentication_management',
    ],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def tfa_disable():
    """
    Two Factor Authentication Disable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/profile/tfa-enable',
    description=""" Generates a Two Factor secret for your User. To enable TFA for your User, enter the secret obtained from this command with the **Two Factor Authentication Confirm/Enable** ([POST /profile/tfa-enable-confirm](/docs/api/profile/#two-factor-authentication-confirmenable)) command.
Once enabled, logins from untrusted computers are required to provide
a TFA code before they are successful.

**Note**: Before you can enable TFA, security questions must be answered for your User by accessing the **Security Questions Answer** ([POST /profile/security-questions](/docs/api/profile/#security-questions-answer)) command.
 """,
    tags=['two_factor_authentication_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def tfa_enable():
    """
    Two Factor Secret Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/profile/tfa-enable-confirm',
    description=""" Confirms that you can successfully generate Two Factor codes and enables TFA on your Account. Once this is complete, login attempts from untrusted computers will be required to provide a Two Factor code before they are successful.
 """,
    tags=['two_factor_authentication_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def tfa_confirm(body: ProfileTfaEnableConfirmPostRequest):
    """
    Two Factor Authentication Confirm/Enable
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/tokens',
    description=""" Returns a paginated list of Personal Access Tokens currently active for your User.
 """,
    tags=['personal_access_token_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_personal_access_tokens():
    """
    Personal Access Tokens List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/profile/tokens',
    description=""" Creates a Personal Access Token for your User. The raw token will be returned in the response, but will never be returned again afterward so be sure to take note of it. You may create a token with _at most_ the scopes of your current token. The created token will be able to access your Account until the given expiry, or until it is revoked.
 """,
    tags=['personal_access_token_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_personal_access_token(body: ProfileTokensPostRequest):
    """
    Personal Access Token Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/profile/tokens/{tokenId}',
    description=""" Revokes a Personal Access Token. The token will be invalidated immediately, and requests using that token will fail with a 401. It is possible to revoke access to the token making the request to revoke a token, but keep in mind that doing so could lose you access to the api and require you to create a new token through some other means.
 """,
    tags=['personal_access_token_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_personal_access_token(token_id: int = Path(..., alias='tokenId')):
    """
    Personal Access Token Revoke
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/profile/tokens/{tokenId}',
    description=""" Returns a single Personal Access Token.
 """,
    tags=['personal_access_token_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_personal_access_token(token_id: int = Path(..., alias='tokenId')):
    """
    Personal Access Token View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/profile/tokens/{tokenId}',
    description=""" Updates a Personal Access Token.
 """,
    tags=['personal_access_token_management', 'account_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_personal_access_token(
    token_id: int = Path(..., alias='tokenId'), body: PersonalAccessToken = ...
):
    """
    Personal Access Token Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/regions',
    description=""" Lists the Regions available for Linode services. Not all services are guaranteed to be
available in all Regions.
 """,
    tags=['region_management'],
)
def get_regions():
    """
    Regions List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/regions/{regionId}',
    description=""" Returns a single Region.
 """,
    tags=['region_management'],
)
def get_region(region_id: str = Path(..., alias='regionId')):
    """
    Region View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/support/tickets',
    description=""" Returns a collection of Support Tickets on your Account. Support Tickets can be both tickets you open with Linode for support, as well as tickets generated by Linode regarding your Account.
This collection includes all Support Tickets generated on your Account, with open tickets returned first.
 """,
    tags=['ticket_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tickets(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Support Tickets List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/support/tickets',
    description=""" Open a Support Ticket.
Only one of the ID attributes (`linode_id`, `domain_id`, etc.) can be set on a single Support Ticket.
 """,
    tags=['ticket_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_ticket(body: SupportTicketRequest = None):
    """
    Support Ticket Open
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/support/tickets/{ticketId}',
    description=""" Returns a Support Ticket under your Account.
 """,
    tags=['ticket_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_ticket(ticket_id: int = Path(..., alias='ticketId')):
    """
    Support Ticket View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/support/tickets/{ticketId}/attachments',
    description=""" Adds a file attachment to an existing Support
Ticket on your Account. File attachments are used to assist our
Support team in resolving your Ticket. Examples of attachments
are screen shots and text files that provide additional information.

The file attachment is submitted in the request as multipart/form-data.

**Note**: Accepted file extensions include: .gif, .jpg, .jpeg, .pjpg,
.pjpeg, .tif, .tiff, .png, .pdf, or .txt.
 """,
    tags=['ticket_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_ticket_attachment(
    ticket_id: int = Path(..., alias='ticketId'), file: UploadFile = ...
):
    """
    Support Ticket Attachment Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/support/tickets/{ticketId}/close',
    description=""" Closes a Support Ticket you have access to modify.
 """,
    tags=['ticket_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def close_ticket(ticket_id: int = Path(..., alias='ticketId')):
    """
    Support Ticket Close
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/support/tickets/{ticketId}/replies',
    description=""" Returns a collection of replies to a Support Ticket on your Account.
 """,
    tags=['ticket_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_ticket_replies(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    ticket_id: int = Path(..., alias='ticketId'),
):
    """
    Replies List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/support/tickets/{ticketId}/replies',
    description=""" Adds a reply to an existing Support Ticket.
 """,
    tags=['ticket_operations'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_ticket_reply(
    ticket_id: int = Path(..., alias='ticketId'),
    body: SupportTicketsTicketIdRepliesPostRequest = ...,
):
    """
    Reply Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags',
    description=""" Tags are User-defined labels attached to objects in your Account, such as Linodes. They are used for specifying and grouping attributes of objects that are relevant to the User.

This endpoint returns a paginated list of Tags on your account.
 """,
    tags=['tag_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tags(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Tags List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags',
    description=""" Creates a new Tag and optionally tags requested objects with it immediately.

**Important**: You must be an unrestricted User in order to add or modify Tags.
 """,
    tags=['tag_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_tag(body: TagsPostRequest = None):
    """
    New Tag Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags/{label}',
    description=""" Remove a Tag from all objects and delete it.

**Important**: You must be an unrestricted User in order to add or modify Tags.
 """,
    tags=['tag_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_tag(label: str):
    """
    Tag Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags/{label}',
    description=""" Returns a paginated list of all objects you've tagged with the requested Tag. This is a mixed collection of all object types.
 """,
    tags=['tag_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tagged_objects(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    label: str = ...,
):
    """
    Tagged Objects List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/volumes',
    description=""" Returns a paginated list of Volumes you have permission to view.
 """,
    tags=['volume_management', 'linode_volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_volumes(
    page: Optional[conint(ge=1)] = 1, page_size: Optional[conint(ge=25, le=500)] = 100
):
    """
    Volumes List
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/volumes',
    description=""" Creates a Volume on your Account. In order for this to complete successfully, your User must have the `add_volumes` grant. Creating a new Volume will start accruing additional charges on your account.
 """,
    tags=['volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_volume(body: VolumesPostRequest):
    """
    Volume Create
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/volumes/{volumeId}',
    description=""" Deletes a Volume you have permission to `read_write`.

* **Deleting a Volume is a destructive action and cannot be undone.**

* Deleting stops billing for the Volume. You will be billed for time used within
the billing period the Volume was active.

* Volumes that are migrating cannot be deleted until the migration is finished.
 """,
    tags=['volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_volume(volume_id: int = Path(..., alias='volumeId')):
    """
    Volume Delete
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/volumes/{volumeId}',
    description=""" Get information about a single Volume.
 """,
    tags=['volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_volume(
    page: Optional[conint(ge=1)] = 1,
    page_size: Optional[conint(ge=25, le=500)] = 100,
    volume_id: int = Path(..., alias='volumeId'),
):
    """
    Volume View
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/volumes/{volumeId}',
    description=""" Updates a Volume that you have permission to `read_write`.
 """,
    tags=['volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_volume(
    volume_id: int = Path(..., alias='volumeId'), body: VolumesVolumeIdPutRequest = ...
):
    """
    Volume Update
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/volumes/{volumeId}/attach',
    description=""" Attaches a Volume on your Account to an existing Linode on your Account. In order for this request to complete successfully, your User must have `read_only` or `read_write` permission to the Volume and `read_write` permission to the Linode. Additionally, the Volume and Linode must be located in the same Region.
 """,
    tags=['volume_management', 'linode_volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def attach_volume(
    volume_id: int = Path(..., alias='volumeId'),
    body: VolumesVolumeIdAttachPostRequest = ...,
):
    """
    Volume Attach
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/volumes/{volumeId}/clone',
    description=""" Creates a Volume on your Account. In order for this request to complete successfully, your User must have the `add_volumes` grant. The new Volume will have the same size and data as the source Volume. Creating a new Volume will incur a charge on your Account.
* Only Volumes with a `status` of "active" can be cloned.
 """,
    tags=['volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def clone_volume(
    volume_id: int = Path(..., alias='volumeId'),
    body: VolumesVolumeIdClonePostRequest = ...,
):
    """
    Volume Clone
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/volumes/{volumeId}/detach',
    description=""" Detaches a Volume on your Account from a Linode on your Account. In order for this request to complete successfully, your User must have `read_write` access to the Volume and `read_write` access to the Linode.
 """,
    tags=['volume_management', 'linode_volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def detach_volume(volume_id: int = Path(..., alias='volumeId')):
    """
    Volume Detach
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/volumes/{volumeId}/resize',
    description=""" Resize an existing Volume on your Account. In order for this request to complete successfully, your User must have the `read_write` permissions to the Volume.
* Volumes can only be resized up.
* Only Volumes with a `status` of "active" can be resized.
 """,
    tags=['volume_management', 'disk_management', 'linode_volume_management'],
    security=[
        HTTPBearer(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def resize_volume(
    volume_id: int = Path(..., alias='volumeId'),
    body: VolumesVolumeIdResizePostRequest = ...,
):
    """
    Volume Resize
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
